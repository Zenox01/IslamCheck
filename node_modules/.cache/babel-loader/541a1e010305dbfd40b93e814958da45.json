{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"prop-types\"), require(\"react\"));else if (typeof define === 'function' && define.amd) define([\"prop-types\", \"react\"], factory);else if (typeof exports === 'object') exports[\"cassetteCore\"] = factory(require(\"prop-types\"), require(\"react\"));else root[\"cassetteCore\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(typeof self !== \"undefined\" ? self : this, function (__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"/dist\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 7);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__1__;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      /* harmony export (binding) */\n\n      __webpack_require__.d(__webpack_exports__, \"a\", function () {\n        return logError;\n      });\n      /* harmony export (binding) */\n\n\n      __webpack_require__.d(__webpack_exports__, \"b\", function () {\n        return logWarning;\n      });\n      /* eslint-disable no-console */\n\n\n      var log = console.log.bind(console);\n      var logError = console.error ? console.error.bind(console) : log;\n      var logWarning = console.warn ? console.warn.bind(console) : log;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (global) {\n        /* harmony import */\n        var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n        /* harmony import */\n\n\n        var react__WEBPACK_IMPORTED_MODULE_0___default =\n        /*#__PURE__*/\n        __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */\n\n\n        var _console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n\n        var packageVersion = __webpack_require__(6).version;\n\n        var _global = typeof window === 'undefined' ? global : window;\n\n        _global.__cassette_contexts__ = _global.__cassette_contexts__ || {};\n\n        function createSingleGlobalContext(_ref) {\n          var displayName = _ref.displayName,\n              _ref$defaultValue = _ref.defaultValue,\n              defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,\n              keysWillUpdate = _ref.keysWillUpdate;\n          var ExistingContext = _global.__cassette_contexts__[displayName];\n\n          if (ExistingContext) {\n            if (ExistingContext.packageVersion !== packageVersion) {\n              Object(_console__WEBPACK_IMPORTED_MODULE_1__[\n              /* logWarning */\n              \"b\"])(\"Warning: multiple versions of \" + displayName + \" from the @cassette/core\" + (\" package have been loaded. v\" + packageVersion + \" will be ignored and\") + (\" v\" + ExistingContext.packageVersion + \" will be used instead.\"));\n            }\n\n            return ExistingContext;\n          } // inspired by:\n          // https://github.com/philosaf/observed-bits/blob/master/src/index.js\n\n\n          var flags = {};\n          var i = 0;\n\n          for (var _iterator = keysWillUpdate, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref2;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref2 = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref2 = _i.value;\n            }\n\n            var key = _ref2;\n            flags[key] = 1 << i++;\n          }\n\n          var Context = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(defaultValue, function getChangedBits(prev, next) {\n            var mask = 0;\n\n            for (var _iterator2 = keysWillUpdate, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n              var _ref3;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref3 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref3 = _i2.value;\n              }\n\n              var key = _ref3;\n\n              if (prev[key] !== next[key]) {\n                mask |= flags[key];\n              }\n            }\n\n            return mask;\n          });\n\n          Context.__cassetteGetObservedBits = function (keys) {\n            var observedBits = 0;\n\n            for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n              var _ref4;\n\n              if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref4 = _iterator3[_i3++];\n              } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref4 = _i3.value;\n              }\n\n              var key = _ref4;\n              observedBits |= flags[key];\n            }\n\n            return observedBits;\n          };\n\n          Context.displayName = displayName;\n          Context.packageVersion = packageVersion;\n          _global.__cassette_contexts__[displayName] = Context;\n          return Context;\n        }\n        /* harmony default export */\n\n\n        __webpack_exports__[\"a\"] = createSingleGlobalContext;\n        /* WEBPACK VAR INJECTION */\n      }).call(this, __webpack_require__(5));\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function (arr, predicate, ctx) {\n        if (typeof Array.prototype.findIndex === 'function') {\n          return arr.findIndex(predicate, ctx);\n        }\n\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n\n        var list = Object(arr);\n        var len = list.length;\n\n        if (len === 0) {\n          return -1;\n        }\n\n        for (var i = 0; i < len; i++) {\n          if (predicate.call(ctx, list[i], i, list)) {\n            return i;\n          }\n        }\n\n        return -1;\n      };\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      var g; // This works in non-strict mode\n\n      g = function () {\n        return this;\n      }();\n\n      try {\n        // This works if eval is allowed (see CSP)\n        g = g || Function(\"return this\")() || (1, eval)(\"this\");\n      } catch (e) {\n        // This works if the window reference is available\n        if (typeof window === \"object\") g = window;\n      } // g can still be undefined, but nothing to do about it...\n      // We return undefined, instead of nothing here, so it's\n      // easier to handle this case. if(!global) { ...}\n\n\n      module.exports = g;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module) {\n      module.exports = {\n        \"name\": \"@cassette/core\",\n        \"version\": \"2.0.0-beta.2\",\n        \"description\": \"A simple, clean, and responsive visual wrapper for the HTML audio tag, built with React.\",\n        \"main\": \"dist/es5/cassette-core.js\",\n        \"scripts\": {\n          \"build:clean\": \"rimraf dist\",\n          \"build:webpack\": \"BUILD_MODE=all webpack --progress\",\n          \"build\": \"npm run build:clean && npm run build:webpack\",\n          \"prepare\": \"npm run build\",\n          \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n        },\n        \"repository\": {\n          \"type\": \"git\",\n          \"url\": \"https://github.com/benwiley4000/cassette.git\"\n        },\n        \"engines\": {\n          \"node\": \">=6.0.0\",\n          \"npm\": \">=5.0.0\"\n        },\n        \"keywords\": [\"audio\", \"video\", \"media\", \"ui\", \"react\", \"reactjs\", \"responsive\", \"music\", \"player\", \"html5\", \"component\", \"components\"],\n        \"author\": {\n          \"name\": \"Ben Wiley\",\n          \"email\": \"therealbenwiley@gmail.com\",\n          \"url\": \"http://benwiley.org/\"\n        },\n        \"license\": \"MIT\",\n        \"peerDependencies\": {\n          \"react\": \"^16.3.0\"\n        },\n        \"devDependencies\": {\n          \"array-find-index\": \"^1.0.2\",\n          \"rimraf\": \"^2.5.4\",\n          \"webpack\": \"^4.17.1\"\n        },\n        \"dependencies\": {\n          \"prop-types\": \"^15.5.10\"\n        },\n        \"publishConfig\": {\n          \"access\": \"public\"\n        },\n        \"gitHead\": \"6466d6adfdf7bfec0b01459e8636712cf912e5ae\"\n      };\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n\n      __webpack_require__.r(__webpack_exports__);\n\n      var PlayerPropTypes_namespaceObject = {};\n\n      __webpack_require__.r(PlayerPropTypes_namespaceObject);\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"controlKeyword\", function () {\n        return controlKeyword;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"control\", function () {\n        return control;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"crossOriginAttribute\", function () {\n        return crossOriginAttribute;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"repeatStrategy\", function () {\n        return PlayerPropTypes_repeatStrategy;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"mediaSource\", function () {\n        return mediaSource;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"mediaSessionAction\", function () {\n        return mediaSessionAction;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"mediaSessionArtwork\", function () {\n        return mediaSessionArtwork;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"track\", function () {\n        return PlayerPropTypes_track;\n      });\n\n      __webpack_require__.d(PlayerPropTypes_namespaceObject, \"seekMode\", function () {\n        return seekMode;\n      }); // EXTERNAL MODULE: external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}\n\n\n      var external_root_React_commonjs_react_commonjs2_react_amd_react_ = __webpack_require__(1);\n\n      var external_root_React_commonjs_react_commonjs2_react_amd_react_default =\n      /*#__PURE__*/\n      __webpack_require__.n(external_root_React_commonjs_react_commonjs2_react_amd_react_); // EXTERNAL MODULE: external {\"root\":\"PropTypes\",\"commonjs\":\"prop-types\",\"commonjs2\":\"prop-types\",\"amd\":\"prop-types\"}\n\n\n      var external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_ = __webpack_require__(0);\n\n      var external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default =\n      /*#__PURE__*/\n      __webpack_require__.n(external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_); // EXTERNAL MODULE: ./node_modules/array-find-index/index.js\n\n\n      var array_find_index = __webpack_require__(4);\n\n      var array_find_index_default =\n      /*#__PURE__*/\n      __webpack_require__.n(array_find_index); // EXTERNAL MODULE: ./src/utils/createSingleGlobalContext.js\n\n\n      var createSingleGlobalContext = __webpack_require__(3); // CONCATENATED MODULE: ./src/PlayerContext.js\n      // TODO: test to make sure context contents stay in sync with\n      // enumerated list here\n\n      /* harmony default export */\n\n\n      var PlayerContext = Object(createSingleGlobalContext[\"a\"\n      /* default */\n      ])({\n        displayName: 'PlayerContext',\n        keysWillUpdate: ['playlist', 'activeTrackIndex', 'trackLoading', 'paused', 'currentTime', 'seekPreviewTime', 'seekInProgress', 'awaitingPlayResume', 'duration', 'bufferedRanges', 'playedRanges', 'seekableRanges', 'volume', 'muted', 'shuffle', 'stalled', 'playbackRate', 'setVolumeInProgress', 'repeatStrategy', 'mediaCannotPlay']\n      }); // CONCATENATED MODULE: ./src/GroupContext.js\n\n      /* harmony default export */\n\n      var GroupContext = Object(createSingleGlobalContext[\"a\"\n      /* default */\n      ])({\n        displayName: 'GroupContext',\n        keysWillUpdate: ['groupProps']\n      }); // CONCATENATED MODULE: ./src/constants.js\n\n      var repeatStrategyOptions = ['none', 'playlist', 'track'];\n      var MEDIA_ERR_NETWORK = 2; // EXTERNAL MODULE: ./src/utils/console.js\n\n      var console = __webpack_require__(2); // CONCATENATED MODULE: ./src/PlayerPropTypes.js\n\n\n      function requiredOnlyUnlessHasProp(propType, altPropName) {\n        var warnedAboutDefiningBoth = false;\n\n        function validate(props, propName, componentName) {\n          if (propName in props) {\n            if (!warnedAboutDefiningBoth && altPropName in props) {\n              Object(console[\"b\"\n              /* logWarning */\n              ])(\"Do not define both the '\" + propName + \"' and '\" + altPropName + \"' props.\");\n              warnedAboutDefiningBoth = true;\n            }\n\n            for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n              rest[_key - 3] = arguments[_key];\n            }\n\n            return propType.isRequired.apply(propType, [props, propName, componentName].concat(rest));\n          }\n\n          if (!(altPropName in props)) {\n            return new Error(\"If the '\" + altPropName + \"' prop is not defined, '\" + propName + \"' must be.\");\n          }\n        }\n\n        return validate;\n      }\n\n      var controlKeyword = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOf(['playpause', 'backskip', 'forwardskip', 'volume', 'mute', 'repeat', 'shuffle', 'progress', 'progressdisplay', 'fullscreen', 'spacer']);\n      var control = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOfType([external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func, controlKeyword]);\n      var crossOriginAttribute = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOf(['anonymous', 'use-credentials']);\n      var PlayerPropTypes_repeatStrategy = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOf(repeatStrategyOptions);\n      var mediaSource = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.shape({\n        src: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string.isRequired,\n        type: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string.isRequired\n      });\n      var mediaSessionAction = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOf(['play', 'pause', 'previoustrack', 'nexttrack', 'seekbackward', 'seekforward']);\n      var mediaSessionArtwork = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.shape({\n        src: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string.isRequired,\n        sizes: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string,\n        type: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string\n      });\n      var PlayerPropTypes_track = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.shape({\n        url: requiredOnlyUnlessHasProp(external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string, 'sources'),\n        sources: requiredOnlyUnlessHasProp(external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.arrayOf(mediaSource.isRequired), 'url'),\n        title: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string.isRequired,\n        artist: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string,\n        album: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string,\n        artwork: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.arrayOf(mediaSessionArtwork.isRequired),\n        duration: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOfType([external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string, external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number]),\n        startingTime: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number,\n        isUnboundedStream: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool,\n        meta: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.object\n      });\n      var seekMode = external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOf(['paused', 'immediate', 'onrelease']); // CONCATENATED MODULE: ./src/factories/createCustomMediaElement.js\n\n      var loopchange = 'loopchange';\n      var srcrequest = 'srcrequest';\n\n      function createCustomMediaElement(media) {\n        new MutationObserver(function () {\n          media.dispatchEvent(new Event(loopchange));\n        }).observe(media, {\n          attributes: true,\n          attributeFilter: ['loop']\n        }); // Don't let the media src property get modified directly.\n        // Instead, when it does get set, dispatch an event to be\n        // handled in a way that doesn't conflict with the loaded\n        // playlist.\n\n        Object.defineProperty(media, 'src', {\n          get: function get() {\n            return media.currentSrc;\n          },\n          set: function set(src) {\n            var e = new Event(srcrequest);\n            e.srcRequested = src;\n            media.dispatchEvent(e);\n          }\n        });\n        return media;\n      }\n      /* harmony default export */\n\n\n      var factories_createCustomMediaElement = createCustomMediaElement; // CONCATENATED MODULE: ./src/utils/ShuffleManager.js\n\n      /* ShuffleManager\n       *\n       * Manages navigation throughout a list which is:\n       * - Sourced from another provided list\n       * - In random order (except to avoid consecutive duplicates)\n       * - Extended endlessly on-the-fly, as needed\n       * - Able to have future history overwritten by non-random choices\n       * - Able to swap source lists and maintain shuffle order for common members\n       */\n\n      var ShuffleManager =\n      /*#__PURE__*/\n      function () {\n        function ShuffleManager(list, options) {\n          if (options === void 0) {\n            options = {};\n          }\n\n          this._list = list;\n          this._forwardStack = [];\n          this._backStack = [];\n          this._currentItem = undefined;\n          this._allowBackShuffle = Boolean(options.allowBackShuffle);\n        }\n\n        var _proto = ShuffleManager.prototype;\n\n        _proto.findNextItem = function findNextItem(currentIndex) {\n          if (currentIndex !== undefined) {\n            this.setCurrentIndex(currentIndex);\n          }\n\n          this._currentItem = _findNextItem(this._list, this._forwardStack, this._backStack, this._currentItem, true);\n          return this._currentItem;\n        };\n\n        _proto.findPreviousItem = function findPreviousItem(currentIndex) {\n          if (currentIndex !== undefined) {\n            this.setCurrentIndex(currentIndex);\n          }\n\n          this._currentItem = _findNextItem(this._list, this._backStack, this._forwardStack, this._currentItem, this._allowBackShuffle);\n          return this._currentItem;\n        };\n\n        _proto.pickNextItem = function pickNextItem(index, currentIndex) {\n          if (currentIndex !== undefined) {\n            this.setCurrentIndex(currentIndex);\n          }\n\n          if (this._list[index] === undefined) {\n            return undefined;\n          }\n\n          if (this._currentItem !== undefined) {\n            this._backStack.push(this._currentItem);\n          }\n\n          this._forwardStack.length = 0;\n          this._currentItem = this._list[index];\n          return this._currentItem;\n        };\n\n        _proto.setList = function setList(list) {\n          this._list = list;\n        };\n\n        _proto.setOptions = function setOptions(options) {\n          var _arr = Object.keys(options);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            var o = _arr[_i];\n\n            switch (o) {\n              case 'allowBackShuffle':\n                this[\"_\" + o] = Boolean(options[o]);\n                break;\n\n              default:\n                break;\n            }\n          }\n        };\n\n        _proto.setCurrentIndex = function setCurrentIndex(currentIndex) {\n          var item = this._list[currentIndex];\n\n          if (this._currentItem !== item) {\n            this.clear();\n            this._currentItem = item;\n          }\n        };\n\n        _proto.clear = function clear() {\n          this._forwardStack.length = 0;\n          this._backStack.length = 0;\n          this._currentItem = undefined;\n        };\n\n        return ShuffleManager;\n      }();\n\n      function _goForward(n, forwardStack, backStack, currentItem) {\n        var item = currentItem;\n\n        for (var i = 0; i < n; i++) {\n          if (!forwardStack.length) {\n            // rollback before erroring (note stack reversal)\n            _goForward(i, backStack, forwardStack, item);\n\n            throw \"Moving \" + n + \" places was not possible!\";\n          }\n\n          backStack.push(item);\n          item = forwardStack.pop();\n        }\n\n        return item;\n      }\n\n      function _allItemsMatch(list, item) {\n        if (!list.length) {\n          return false;\n        }\n\n        for (var i = 0; i < list.length; i++) {\n          if (item !== list[i]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function _findNextItem(list, forwardStack, backStack, currentItem, allowMore) {\n        var item = currentItem;\n\n        if (!list.length) {\n          return undefined;\n        }\n\n        for (var i = 1; i <= forwardStack.length; i++) {\n          if (list.indexOf(forwardStack[forwardStack.length - i]) !== -1) {\n            return _goForward(i, forwardStack, backStack, item);\n          }\n        }\n\n        if (!allowMore) {\n          return undefined;\n        }\n\n        if (_allItemsMatch(list, item)) {\n          // we can serve this as our \"next\" item but we\n          // won't modify our history since it's the same.\n          return item;\n        }\n\n        var nextItem;\n\n        do {\n          nextItem = list[Math.floor(Math.random() * list.length)];\n        } while (item === nextItem || nextItem === undefined); // if we're skipping items that aren't in our current list we may\n        // have some items in our forwardStack - make sure we move to the front.\n\n\n        item = _goForward(forwardStack.length, forwardStack, backStack, item);\n\n        if (item !== undefined) {\n          backStack.push(item);\n        }\n\n        return nextItem;\n      }\n      /* harmony default export */\n\n\n      var utils_ShuffleManager = ShuffleManager; // CONCATENATED MODULE: ./src/utils/isPlaylistValid.js\n\n      function isPlaylistValid(playlist) {\n        return Boolean(playlist && playlist.length);\n      }\n      /* harmony default export */\n\n\n      var utils_isPlaylistValid = isPlaylistValid; // CONCATENATED MODULE: ./src/utils/getTrackSources.js\n\n      var blankSources = [{\n        src: ''\n      }];\n\n      function getTrackSources(playlist, index) {\n        if (!utils_isPlaylistValid(playlist)) {\n          return blankSources;\n        }\n\n        var _playlist$index = playlist[index],\n            sources = _playlist$index.sources,\n            url = _playlist$index.url;\n\n        if (sources) {\n          return sources.length ? sources : blankSources;\n        }\n\n        return [{\n          src: url\n        }];\n      }\n      /* harmony default export */\n\n\n      var utils_getTrackSources = getTrackSources; // CONCATENATED MODULE: ./src/utils/findTrackIndexByUrl.js\n\n      function findTrackIndexByUrl(playlist, url) {\n        return array_find_index_default()(playlist, function (track) {\n          if (track.sources) {\n            return array_find_index_default()(track.sources, function (source) {\n              return source.src === url;\n            }) !== -1;\n          }\n\n          return track.url && url === track.url;\n        });\n      }\n      /* harmony default export */\n\n\n      var utils_findTrackIndexByUrl = findTrackIndexByUrl; // CONCATENATED MODULE: ./src/utils/snapshot.js\n\n      function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      var veryLongKey = '__highly_unstable_snapshot_internals_which_will_break_your_app_if_you_use_them_directly__';\n      var versionKey = '__cassette_snapshot_version__'; // IMPORTANT: new migrations *must* always be added to the end since\n      // the tracked snapshot version is based on the migration index.\n      // If there is a crash-inducing bug in an existing migration, it can be patched\n      // in-place, but it should never be removed from the migrations array.\n\n      var migrations = [function (oldSnapshot) {\n        var _objectSpread2;\n\n        var __unstable__ = oldSnapshot.__unstable__,\n            rest = _objectWithoutPropertiesLoose(oldSnapshot, [\"__unstable__\"]);\n\n        return _objectSpread({}, rest, (_objectSpread2 = {}, _objectSpread2[veryLongKey] = __unstable__, _objectSpread2));\n      }];\n\n      function getStateSnapshot(state) {\n        var _ref;\n\n        var paused = state.paused,\n            currentTime = state.currentTime,\n            activeTrackIndex = state.activeTrackIndex,\n            volume = state.volume,\n            muted = state.muted,\n            loop = state.loop,\n            cycle = state.cycle,\n            shuffle = state.shuffle,\n            playbackRate = state.playbackRate,\n            duration = state.duration,\n            __playlist__ = state.__playlist__;\n        return _ref = {}, _ref[versionKey] = migrations.length, _ref[veryLongKey] = {\n          paused: paused,\n          // currentTime can't be restored for unbounded live streams\n          currentTime: duration === Infinity ? 0 : currentTime,\n          activeTrackIndex: activeTrackIndex,\n          volume: volume,\n          muted: muted,\n          loop: loop,\n          cycle: cycle,\n          shuffle: shuffle,\n          playbackRate: playbackRate,\n          activeTrackSrc: utils_isPlaylistValid(__playlist__) ? utils_getTrackSources(__playlist__, activeTrackIndex)[0].src : null\n        }, _ref;\n      }\n\n      function restoreStateFromSnapshot(snapshot, props) {\n        var migratedSnapshot = migrations.slice(snapshot[versionKey] || 0).reduce(function (oldSnapshot, migration) {\n          return migration(oldSnapshot);\n        }, snapshot);\n        var _migratedSnapshot$ver = migratedSnapshot[veryLongKey],\n            paused = _migratedSnapshot$ver.paused,\n            currentTime = _migratedSnapshot$ver.currentTime,\n            activeTrackIndex = _migratedSnapshot$ver.activeTrackIndex,\n            volume = _migratedSnapshot$ver.volume,\n            muted = _migratedSnapshot$ver.muted,\n            loop = _migratedSnapshot$ver.loop,\n            cycle = _migratedSnapshot$ver.cycle,\n            shuffle = _migratedSnapshot$ver.shuffle,\n            playbackRate = _migratedSnapshot$ver.playbackRate,\n            activeTrackSrc = _migratedSnapshot$ver.activeTrackSrc;\n        var restoredStateValues = {};\n\n        if (utils_isPlaylistValid(props.playlist) && typeof paused === 'boolean') {\n          // using awaitingPlay instead of paused triggers an animation\n          restoredStateValues.awaitingPlay = !paused;\n        }\n\n        if (typeof volume === 'number' && volume >= 0 && volume <= 1) {\n          restoredStateValues.volume = volume;\n        }\n\n        if (typeof muted === 'boolean') {\n          restoredStateValues.muted = muted;\n        }\n\n        if (typeof loop === 'boolean') {\n          restoredStateValues.loop = loop;\n        }\n\n        if (typeof cycle === 'boolean') {\n          restoredStateValues.cycle = cycle;\n        }\n\n        if (typeof shuffle === 'boolean') {\n          restoredStateValues.shuffle = shuffle;\n        }\n\n        if (typeof playbackRate === 'number') {\n          restoredStateValues.playbackRate = playbackRate;\n        }\n\n        var useCurrentTime = false;\n\n        if (typeof activeTrackSrc === 'string' && typeof activeTrackIndex === 'number' && activeTrackIndex >= 0) {\n          // let's try staying on the same track index\n          var currentSrc = props.playlist[activeTrackIndex] && utils_getTrackSources(props.playlist, activeTrackIndex)[0].src;\n\n          if (currentSrc && activeTrackSrc === currentSrc) {\n            restoredStateValues.activeTrackIndex = activeTrackIndex;\n            useCurrentTime = true;\n          } else {\n            /* if the track we were playing before is in the new playlist,\n             * update the activeTrackIndex.\n             */\n            var newTrackIndex = utils_findTrackIndexByUrl(props.playlist, activeTrackSrc);\n\n            if (newTrackIndex !== -1) {\n              restoredStateValues.activeTrackIndex = newTrackIndex;\n              useCurrentTime = true;\n            }\n          }\n        }\n\n        if (useCurrentTime && typeof currentTime === 'number' && currentTime >= 0) {\n          restoredStateValues.currentTime = currentTime;\n        }\n\n        return restoredStateValues;\n      } // CONCATENATED MODULE: ./src/utils/getSourceList.js\n      // collapses playlist into flat list containing\n      // the first source url for each track\n\n\n      function getSourceList(playlist) {\n        return (playlist || []).map(function (_, i) {\n          return utils_getTrackSources(playlist, i)[0].src;\n        });\n      }\n      /* harmony default export */\n\n\n      var utils_getSourceList = getSourceList; // CONCATENATED MODULE: ./src/utils/getTimeRangesArray.js\n\n      function getTimeRangesArray(timeRangesObj) {\n        var timeRangesArray = Array(timeRangesObj.length);\n\n        for (var i = 0; i < timeRangesObj.length; i++) {\n          timeRangesArray[i] = {\n            start: timeRangesObj.start(i),\n            end: timeRangesObj.end(i)\n          };\n        }\n\n        return timeRangesArray;\n      }\n      /* harmony default export */\n\n\n      var utils_getTimeRangesArray = getTimeRangesArray; // CONCATENATED MODULE: ./src/utils/getRepeatStrategy.js\n\n      function getRepeatStrategy(loop, cycle) {\n        if (loop) {\n          return 'track';\n        }\n\n        if (cycle) {\n          return 'playlist';\n        }\n\n        return 'none';\n      }\n      /* harmony default export */\n\n\n      var utils_getRepeatStrategy = getRepeatStrategy; // CONCATENATED MODULE: ./src/utils/convertToNumberWithinIntervalBounds.js\n\n      function convertToNumberWithinIntervalBounds(number, min, max) {\n        min = typeof min === 'number' ? min : -Infinity;\n        max = typeof max === 'number' ? max : Infinity;\n        return Math.max(min, Math.min(number, max));\n      }\n      /* harmony default export */\n\n\n      var utils_convertToNumberWithinIntervalBounds = convertToNumberWithinIntervalBounds; // CONCATENATED MODULE: ./src/utils/getDisplayText.js\n\n      function getDisplayText(track) {\n        if (!track) {\n          return '';\n        }\n\n        if (track.title && track.artist) {\n          return track.artist + \" - \" + track.title;\n        }\n\n        return track.title || track.artist || track.album || '';\n      }\n      /* harmony default export */\n\n\n      var utils_getDisplayText = getDisplayText; // CONCATENATED MODULE: ./src/utils/parseTimeString.js\n\n      function parseTimeString(str) {\n        var seconds = 0;\n        var factor = 1;\n        var times = str.split(':').slice(-3);\n\n        while (times.length > 0) {\n          seconds += factor * parseInt(times.pop(), 10);\n          factor *= 60;\n        }\n\n        return seconds;\n      }\n      /* harmony default export */\n\n\n      var utils_parseTimeString = parseTimeString; // CONCATENATED MODULE: ./src/utils/getInitialDuration.js\n\n      function getInitialDuration(track) {\n        var duration = 0;\n\n        if (track.duration) {\n          if (typeof track.duration === 'string') {\n            duration = utils_parseTimeString(track.duration);\n          } else {\n            duration = track.duration;\n          }\n        }\n\n        return duration;\n      }\n      /* harmony default export */\n\n\n      var utils_getInitialDuration = getInitialDuration; // CONCATENATED MODULE: ./src/PlayerContextProvider.js\n\n      function _extends() {\n        _extends = Object.assign || function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n\n          return target;\n        };\n\n        return _extends.apply(this, arguments);\n      }\n\n      function PlayerContextProvider_objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      function PlayerContextProvider_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            PlayerContextProvider_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function PlayerContextProvider_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function playErrorHandler(err) {\n        Object(console[\"a\"\n        /* logError */\n        ])(err);\n\n        if (err.name === 'NotAllowedError') {\n          var warningMessage = 'Media playback failed at ' + new Date().toLocaleTimeString() + '! (Perhaps autoplay is disabled in this browser.)';\n          Object(console[\"b\"\n          /* logWarning */\n          ])(warningMessage);\n        }\n      } // Existing Media Session API implementations have default handlers\n      // for play/pause, and may yield unexpected behavior if custom\n      // play/pause handlers are defined - so let's leave them be.\n\n\n      var supportableMediaSessionActions = ['previoustrack', 'nexttrack', 'seekbackward', 'seekforward'];\n      var defaultState = {\n        // indicates whether media player should be paused\n        paused: true,\n        // elapsed time for active track, in seconds\n        currentTime: 0,\n        // The most recent targeted time, in seconds, for seek preview\n        seekPreviewTime: 0,\n\n        /* true if the user is currently dragging the mouse\n         * to seek a new track position\n         */\n        seekInProgress: false,\n\n        /* true if media was playing when seek previewing began,\n         * it was paused, and it should be resumed on seek\n         * complete\n         */\n        awaitingResumeOnSeekComplete: false,\n        // true if media will play once new track has loaded\n        awaitingPlayAfterTrackLoad: false,\n        // the duration in seconds of the loaded track\n        duration: 0,\n        // array describing the buffered ranges in the loaded track\n        bufferedRanges: [],\n        // array describing the already-played ranges in the loaded track\n        playedRanges: [],\n        // array describing the seekable ranges in the loaded track\n        seekableRanges: [],\n        // true if the media is currently stalled pending data buffering\n        stalled: false,\n        // true if the active track should play on the next componentDidUpdate\n        shouldRequestPlayOnNextUpdate: false,\n\n        /* true if an error occurs while fetching the active track media data\n         * or if its type is not a supported media format\n         */\n        mediaCannotPlay: false,\n        // maximum currentTime since the current track has been playing\n        maxKnownTime: 0\n      }; // assumes playlist is valid\n\n      function getGoToTrackState(_ref) {\n        var prevState = _ref.prevState,\n            index = _ref.index,\n            track = _ref.track,\n            _ref$shouldPlay = _ref.shouldPlay,\n            shouldPlay = _ref$shouldPlay === void 0 ? true : _ref$shouldPlay,\n            _ref$shouldForceLoad = _ref.shouldForceLoad,\n            shouldForceLoad = _ref$shouldForceLoad === void 0 ? false : _ref$shouldForceLoad,\n            startingTime = _ref.startingTime;\n        var isNewTrack = prevState.activeTrackIndex !== index;\n        var shouldLoadAsNew = Boolean(isNewTrack || shouldForceLoad);\n        var currentTime = startingTime || track.startingTime || 0;\n        return {\n          duration: utils_getInitialDuration(track),\n          activeTrackIndex: index,\n          trackLoading: shouldLoadAsNew,\n          mediaCannotPlay: prevState.mediaCannotPlay && !shouldLoadAsNew,\n          currentTime: utils_convertToNumberWithinIntervalBounds(currentTime, 0),\n          loop: shouldLoadAsNew ? false : prevState.loop,\n          shouldRequestPlayOnNextUpdate: Boolean(shouldPlay),\n          awaitingPlayAfterTrackLoad: Boolean(shouldPlay),\n          awaitingForceLoad: Boolean(shouldForceLoad),\n          maxKnownTime: shouldLoadAsNew ? 0 : prevState.maxKnownTime\n        };\n      }\n      /**\n       * Wraps an area which shares a common [`playerContext`](#playercontext)\n       */\n\n\n      var PlayerContextProvider_PlayerContextProvider =\n      /*#__PURE__*/\n      function (_Component) {\n        _inheritsLoose(PlayerContextProvider, _Component);\n\n        function PlayerContextProvider(props) {\n          var _this;\n\n          _this = _Component.call(this, props) || this;\n          var currentTime = 0;\n          var activeTrackIndex = utils_convertToNumberWithinIntervalBounds(props.startingTrackIndex, 0);\n          var playlistIsValid = utils_isPlaylistValid(props.playlist);\n\n          if (playlistIsValid && props.playlist[activeTrackIndex]) {\n            currentTime = props.playlist[activeTrackIndex].startingTime || 0;\n          }\n\n          var initialStateSnapshot = props.initialStateSnapshot;\n          var restoredStateFromSnapshot = {};\n\n          if (initialStateSnapshot) {\n            try {\n              restoredStateFromSnapshot = restoreStateFromSnapshot(initialStateSnapshot, props);\n              var _restoredStateFromSna = restoredStateFromSnapshot,\n                  a = _restoredStateFromSna.activeTrackIndex,\n                  c = _restoredStateFromSna.currentTime;\n\n              if (typeof a === 'number') {\n                activeTrackIndex = a;\n              }\n\n              if (typeof c === 'number') {\n                currentTime = c;\n              }\n            } catch (err) {\n              Object(console[\"b\"\n              /* logWarning */\n              ])(err);\n              Object(console[\"b\"\n              /* logWarning */\n              ])('Loading Cassette state from snapshot failed.');\n              Object(console[\"b\"\n              /* logWarning */\n              ])(\"Failed snapshot:\\n\" + JSON.stringify(initialStateSnapshot, null, 2));\n            }\n          }\n\n          _this.state = PlayerContextProvider_objectSpread({}, defaultState, {\n            // index matching requested track (whether track has loaded or not)\n            activeTrackIndex: activeTrackIndex,\n            // whether we're waiting on loading metadata for the active track\n            trackLoading: utils_isPlaylistValid(props.playlist),\n            // the current timestamp on the active track in seconds\n            currentTime: utils_convertToNumberWithinIntervalBounds(currentTime, 0),\n            // the latest volume of the media, between 0 and 1.\n            volume: utils_convertToNumberWithinIntervalBounds(props.defaultVolume, 0, 1),\n            // true if the media has been muted\n            muted: props.defaultMuted,\n            // whether to loop the active track\n            loop: props.defaultRepeatStrategy === 'track',\n            // true if playlist should continue at start after completion\n            cycle: props.defaultRepeatStrategy === 'playlist',\n            // whether to randomly pick next track from playlist after one finishes\n            shuffle: props.defaultShuffle,\n            // Rate at which media should be played. 1.0 is normal speed.\n            playbackRate: props.defaultPlaybackRate,\n            // true if user is currently dragging mouse to change the volume\n            setVolumeInProgress: false,\n            // initialize shouldRequestPlayOnNextUpdate from autoplay prop\n            shouldRequestPlayOnNextUpdate: props.autoplay && playlistIsValid,\n            awaitingForceLoad: false,\n            // duration might be set on track object\n            duration: utils_getInitialDuration(playlistIsValid && props.playlist[activeTrackIndex]),\n            // playlist prop copied to state (for getDerivedStateFromProps)\n            __playlist__: props.playlist\n          }, restoredStateFromSnapshot); // volume at last time we were unmuted and not actively setting volume\n\n          _this.lastStableVolume = _this.state.volume; // used to keep track of play history when we are shuffling\n\n          _this.shuffler = new utils_ShuffleManager(utils_getSourceList(props.playlist), {\n            allowBackShuffle: props.allowBackShuffle\n          }); // html media element used for playback\n\n          _this.media = null;\n          _this.videoHostElementList = [];\n          _this.videoHostOccupiedCallbacks = new Map();\n          _this.videoHostVacatedCallbacks = new Map(); // bind internal methods\n\n          _this.handleTrackPlaybackFailure = _this.handleTrackPlaybackFailure.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handlePlayerOnlineAfterFailure = _this.handlePlayerOnlineAfterFailure.bind(_assertThisInitialized(_assertThisInitialized(_this))); // bind callback methods to pass to descendant elements\n\n          _this.togglePause = _this.togglePause.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.selectTrackIndex = _this.selectTrackIndex.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.forwardSkip = _this.forwardSkip.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.backSkip = _this.backSkip.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.seekPreview = _this.seekPreview.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.seekComplete = _this.seekComplete.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.setVolume = _this.setVolume.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.setVolumeComplete = _this.setVolumeComplete.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.toggleMuted = _this.toggleMuted.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.toggleShuffle = _this.toggleShuffle.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.setRepeatStrategy = _this.setRepeatStrategy.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.setPlaybackRate = _this.setPlaybackRate.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.registerVideoHostElement = _this.registerVideoHostElement.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.renderVideoIntoHostElement = _this.renderVideoIntoHostElement.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.unregisterVideoHostElement = _this.unregisterVideoHostElement.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.updateVideoHostElement = _this.updateVideoHostElement.bind(_assertThisInitialized(_assertThisInitialized(_this))); // bind media event handlers\n\n          _this.handleMediaPlay = _this.handleMediaPlay.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaPause = _this.handleMediaPause.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaSrcrequest = _this.handleMediaSrcrequest.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaEnded = _this.handleMediaEnded.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaEmptied = _this.handleMediaEmptied.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaStalled = _this.handleMediaStalled.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaCanplaythrough = _this.handleMediaCanplaythrough.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaCanplay = _this.handleMediaCanplay.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaTimeupdate = _this.handleMediaTimeupdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaLoadeddata = _this.handleMediaLoadeddata.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaVolumechange = _this.handleMediaVolumechange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaDurationchange = _this.handleMediaDurationchange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaProgress = _this.handleMediaProgress.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaLoopchange = _this.handleMediaLoopchange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          _this.handleMediaRatechange = _this.handleMediaRatechange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n          return _this;\n        }\n\n        var _proto = PlayerContextProvider.prototype;\n\n        _proto.componentDidMount = function componentDidMount() {\n          var _this2 = this;\n\n          var media = this.media = factories_createCustomMediaElement(this.props.createMediaElement());\n          var _this$props = this.props,\n              defaultPlaybackRate = _this$props.defaultPlaybackRate,\n              crossOrigin = _this$props.crossOrigin,\n              playlist = _this$props.playlist,\n              autoplayDelayInSeconds = _this$props.autoplayDelayInSeconds,\n              mediaElementRef = _this$props.mediaElementRef,\n              getPosterImageForTrack = _this$props.getPosterImageForTrack,\n              getMediaTitleAttributeForTrack = _this$props.getMediaTitleAttributeForTrack,\n              onActiveTrackUpdate = _this$props.onActiveTrackUpdate;\n          var _this$state = this.state,\n              volume = _this$state.volume,\n              muted = _this$state.muted,\n              playbackRate = _this$state.playbackRate,\n              loop = _this$state.loop,\n              activeTrackIndex = _this$state.activeTrackIndex,\n              shouldRequestPlayOnNextUpdate = _this$state.shouldRequestPlayOnNextUpdate; // initialize media properties\n          // We used to set currentTime here.. now waiting for loadeddata.\n          // This avoids an issue where some browsers ignore or delay currentTime\n          // updates when in the HAVE_NOTHING state.\n\n          media.defaultPlaybackRate = defaultPlaybackRate;\n\n          if (crossOrigin) {\n            media.crossOrigin = crossOrigin;\n          }\n\n          media.volume = volume;\n          media.muted = muted;\n          media.playbackRate = playbackRate;\n          media.loop = loop;\n          media.setAttribute('playsinline', '');\n          media.setAttribute('webkit-playsinline', '');\n          media.setAttribute('preload', 'metadata');\n          media.setAttribute('poster', getPosterImageForTrack(playlist[activeTrackIndex]));\n          media.setAttribute('title', getMediaTitleAttributeForTrack(playlist[activeTrackIndex])); // add listeners for media events\n\n          media.addEventListener('play', this.handleMediaPlay);\n          media.addEventListener('pause', this.handleMediaPause);\n          media.addEventListener('ended', this.handleMediaEnded);\n          media.addEventListener('stalled', this.handleMediaStalled);\n          media.addEventListener('emptied', this.handleMediaEmptied);\n          media.addEventListener('canplay', this.handleMediaCanplay);\n          media.addEventListener('canplaythrough', this.handleMediaCanplaythrough);\n          media.addEventListener('timeupdate', this.handleMediaTimeupdate);\n          media.addEventListener('loadeddata', this.handleMediaLoadeddata);\n          media.addEventListener('volumechange', this.handleMediaVolumechange);\n          media.addEventListener('durationchange', this.handleMediaDurationchange);\n          media.addEventListener('progress', this.handleMediaProgress);\n          media.addEventListener('ratechange', this.handleMediaRatechange);\n          media.addEventListener('error', this.handleTrackPlaybackFailure); // add listeners for special events\n\n          media.addEventListener('srcrequest', this.handleMediaSrcrequest);\n          media.addEventListener('loopchange', this.handleMediaLoopchange); // set source elements for current track\n\n          this.setMediaElementSources(); // initially mount media element in the hidden container (this may change)\n\n          this.mediaContainer.appendChild(media);\n\n          if (shouldRequestPlayOnNextUpdate) {\n            this.setState({\n              shouldRequestPlayOnNextUpdate: false\n            });\n            this.delayTimeout = setTimeout(function () {\n              _this2.togglePause(false);\n            }, autoplayDelayInSeconds * 1000);\n          }\n\n          if (mediaElementRef) {\n            mediaElementRef(media);\n          }\n\n          if (onActiveTrackUpdate) {\n            onActiveTrackUpdate({\n              track: playlist[activeTrackIndex],\n              trackIndex: activeTrackIndex,\n              previousTrack: null,\n              previousTrackIndex: null\n            });\n          }\n        };\n\n        PlayerContextProvider.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n          var newPlaylist = nextProps.playlist;\n\n          if (newPlaylist === prevState.__playlist__) {\n            // reference comparison is equal so we'll\n            // assume the playlist is unchanged.\n            return null;\n          }\n\n          var baseNewState = {\n            __playlist__: newPlaylist\n          }; // check if the new playlist is invalid\n\n          if (!utils_isPlaylistValid(newPlaylist)) {\n            return PlayerContextProvider_objectSpread({}, defaultState, baseNewState, {\n              activeTrackIndex: 0,\n              trackLoading: false\n            });\n          } // check if the activeTrackIndex doesn't need to be updated\n\n\n          var prevSources = utils_getTrackSources(prevState.__playlist__, prevState.activeTrackIndex);\n\n          if (newPlaylist[prevState.activeTrackIndex]) {\n            // the sources if we stay on the same track index\n            var currentSources = utils_getTrackSources(newPlaylist, prevState.activeTrackIndex); // non-comprehensive but probably accurate check\n\n            if (prevSources[0].src === currentSources[0].src) {\n              // our active track index already matches\n              return baseNewState;\n            }\n          }\n          /* if the track we're already playing is in the new playlist, update the\n           * activeTrackIndex.\n           */\n\n\n          var newTrackIndex = utils_findTrackIndexByUrl(newPlaylist, prevSources[0].src);\n\n          if (newTrackIndex !== -1) {\n            return PlayerContextProvider_objectSpread({}, baseNewState, {\n              activeTrackIndex: newTrackIndex\n            });\n          } // if not, then load the first track in the new playlist, and pause.\n\n\n          return PlayerContextProvider_objectSpread({}, baseNewState, getGoToTrackState({\n            prevState: prevState,\n            track: newPlaylist[0],\n            index: 0,\n            shouldPlay: false,\n            shouldForceLoad: true\n          }), {\n            mediaCannotPlay: false,\n            awaitingPlayAfterTrackLoad: false\n          });\n        };\n\n        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n          var _this3 = this;\n\n          this.media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n          this.media.crossOrigin = this.props.crossOrigin;\n          this.shuffler.setList(utils_getSourceList(this.props.playlist));\n          this.shuffler.setOptions({\n            allowBackShuffle: this.props.allowBackShuffle\n          });\n          var prevSources = utils_getTrackSources(prevProps.playlist, prevState.activeTrackIndex);\n          var newSources = utils_getTrackSources(this.props.playlist, this.state.activeTrackIndex);\n          var prevTrack = prevProps.playlist[prevState.activeTrackIndex];\n          var newTrack = this.props.playlist[this.state.activeTrackIndex];\n\n          if (this.state.awaitingForceLoad || prevSources[0].src !== newSources[0].src) {\n            this.setMediaElementSources();\n            this.media.setAttribute('poster', this.props.getPosterImageForTrack(newTrack));\n            this.media.setAttribute('title', this.props.getMediaTitleAttributeForTrack(newTrack));\n            this.setState({\n              awaitingForceLoad: false\n            });\n\n            if (!this.state.shuffle) {\n              // after toggling off shuffle, we defer clearing the shuffle\n              // history until we actually change tracks - if the user quickly\n              // toggles  shuffle off then back on again, we don't want to have\n              // lost our history.\n              this.shuffler.clear();\n            } // If track changes before player is back online, the previous track\n            // shouldn't be reloaded.\n\n\n            window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n          }\n\n          if (this.props.onActiveTrackUpdate && prevTrack !== newTrack) {\n            this.props.onActiveTrackUpdate({\n              track: newTrack,\n              trackIndex: this.state.activeTrackIndex,\n              previousTrack: prevTrack,\n              previousTrackIndex: prevState.activeTrackIndex\n            });\n          }\n\n          if (prevProps !== this.props && !this.media.paused) {\n            // update running media session based on new props\n            this.stealMediaSession();\n          }\n\n          if (this.state.shouldRequestPlayOnNextUpdate) {\n            this.setState({\n              shouldRequestPlayOnNextUpdate: false\n            }); // media.currentSrc is updated asynchronously so we should\n            // play async to avoid weird intermediate state issues\n\n            setTimeout(function () {\n              _this3.togglePause(false);\n            });\n          }\n\n          clearTimeout(this.snapshotUpdateTimeout);\n          this.snapshotUpdateTimeout = setTimeout(function () {\n            if (_this3.props.onStateSnapshot) {\n              _this3.props.onStateSnapshot(getStateSnapshot(_this3.state));\n            }\n          }, 100);\n        };\n\n        _proto.componentWillUnmount = function componentWillUnmount() {\n          var media = this.media; // Media element creation will have failed if MutationObserver isn't\n          // supported by the browser. The parent might use an Error Boundary\n          // to display a fallback and so we try to avoid triggering *additional*\n          // errors while the component unmounts.\n\n          if (media) {\n            // remove listeners for media events\n            media.removeEventListener('play', this.handleMediaPlay);\n            media.removeEventListener('pause', this.handleMediaPause);\n            media.removeEventListener('ended', this.handleMediaEnded);\n            media.removeEventListener('stalled', this.handleMediaStalled);\n            media.removeEventListener('emptied', this.handleMediaEmptied);\n            media.removeEventListener('canplaythrough', this.handleMediaCanplaythrough);\n            media.removeEventListener('canplay', this.handleMediaCanplay);\n            media.removeEventListener('timeupdate', this.handleMediaTimeupdate);\n            media.removeEventListener('loadeddata', this.handleMediaLoadeddata);\n            media.removeEventListener('volumechange', this.handleMediaVolumechange);\n            media.removeEventListener('durationchange', this.handleMediaDurationchange);\n            media.removeEventListener('progress', this.handleMediaProgress);\n            media.removeEventListener('ratechange', this.handleMediaRatechange);\n            media.removeEventListener('error', this.handleTrackPlaybackFailure); // remove special event listeners on the media element\n\n            media.removeEventListener('srcrequest', this.handleMediaSrcrequest);\n            media.removeEventListener('loopchange', this.handleMediaLoopchange);\n            var sourceElements = media.querySelectorAll('source');\n\n            for (var _iterator = sourceElements, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n              var _ref2;\n\n              if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref2 = _iterator[_i++];\n              } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref2 = _i.value;\n              }\n\n              var sourceElement = _ref2;\n              sourceElement.removeEventListener('error', this.handleTrackPlaybackFailure);\n            }\n          }\n\n          clearTimeout(this.gapLengthTimeout);\n          clearTimeout(this.delayTimeout);\n          window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n        };\n\n        _proto.stealMediaSession = function stealMediaSession() {\n          var _this4 = this;\n\n          if ( // eslint-disable-next-line no-undef\n          !(window.MediaSession && navigator.mediaSession instanceof MediaSession)) {\n            return;\n          } // eslint-disable-next-line no-undef\n\n\n          navigator.mediaSession.metadata = new MediaMetadata(this.props.playlist[this.state.activeTrackIndex]);\n          supportableMediaSessionActions.map(function (action) {\n            if (_this4.props.supportedMediaSessionActions.indexOf(action) === -1) {\n              return null;\n            }\n\n            var seekLength = _this4.props.mediaSessionSeekLengthInSeconds;\n\n            switch (action) {\n              case 'play':\n                return _this4.togglePause.bind(_this4, false);\n\n              case 'pause':\n                return _this4.togglePause.bind(_this4, true);\n\n              case 'previoustrack':\n                return _this4.backSkip;\n\n              case 'nexttrack':\n                return _this4.forwardSkip;\n\n              case 'seekbackward':\n                return function () {\n                  return _this4.media.currentTime -= seekLength;\n                };\n\n              case 'seekforward':\n                return function () {\n                  return _this4.media.currentTime += seekLength;\n                };\n\n              default:\n                return undefined;\n            }\n          }).forEach(function (handler, i) {\n            navigator.mediaSession.setActionHandler(supportableMediaSessionActions[i], handler);\n          });\n        };\n\n        _proto.setMediaElementSources = function setMediaElementSources() {\n          // remove current sources\n          var playlist = this.props.playlist;\n          var firstChild;\n\n          while (firstChild = this.media.firstChild) {\n            this.media.removeChild(firstChild);\n          }\n\n          if (utils_isPlaylistValid(playlist)) {\n            var sources = utils_getTrackSources(playlist, this.state.activeTrackIndex); // add new sources\n\n            for (var _iterator2 = sources, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n              var _ref3;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref3 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref3 = _i2.value;\n              }\n\n              var source = _ref3;\n              var sourceElement = document.createElement('source');\n              sourceElement.src = source.src;\n\n              if (source.type) {\n                sourceElement.type = source.type;\n              }\n\n              sourceElement.addEventListener('error', this.handleTrackPlaybackFailure);\n              this.media.appendChild(sourceElement);\n            }\n          } // cancel playback and re-scan new sources\n\n\n          this.media.load();\n        };\n\n        _proto.reloadActiveTrack = function reloadActiveTrack(_temp) {\n          var _ref4 = _temp === void 0 ? {} : _temp,\n              _ref4$shouldPlay = _ref4.shouldPlay,\n              shouldPlay = _ref4$shouldPlay === void 0 ? false : _ref4$shouldPlay;\n\n          var playlist = this.props.playlist;\n          var _this$state2 = this.state,\n              activeTrackIndex = _this$state2.activeTrackIndex,\n              paused = _this$state2.paused,\n              currentTime = _this$state2.currentTime;\n\n          if (!utils_isPlaylistValid(playlist)) {\n            return;\n          }\n\n          this.goToTrack({\n            track: playlist[activeTrackIndex],\n            shouldForceLoad: true,\n            shouldPlay: shouldPlay || !paused,\n            startingTime: currentTime,\n            index: activeTrackIndex\n          });\n        };\n\n        _proto.handlePlayerOnlineAfterFailure = function handlePlayerOnlineAfterFailure() {\n          this.reloadActiveTrack();\n          window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n        };\n\n        _proto.handleTrackPlaybackFailure = function handleTrackPlaybackFailure(event) {\n          var shouldPlay = !this.state.paused;\n          this.setState({\n            mediaCannotPlay: true\n          });\n          var error = event.target.error; // If there's a network error, the current track should be reloaded\n          // in order to recover from the error state the player is in.\n\n          if (event.target === this.media && error && error.code === MEDIA_ERR_NETWORK) {\n            if (window.navigator.onLine) {\n              this.reloadActiveTrack({\n                shouldPlay: shouldPlay\n              });\n            } else {\n              window.addEventListener('online', this.handlePlayerOnlineAfterFailure);\n            }\n          }\n\n          if (this.props.onTrackPlaybackFailure) {\n            this.props.onTrackPlaybackFailure({\n              track: this.props.playlist[this.state.activeTrackIndex],\n              trackIndex: this.state.activeTrackIndex,\n              event: event\n            });\n          }\n        };\n\n        _proto.registerVideoHostElement = function registerVideoHostElement(hostElement, _ref5) {\n          var onHostOccupied = _ref5.onHostOccupied,\n              onHostVacated = _ref5.onHostVacated;\n          this.videoHostElementList = this.videoHostElementList.concat(hostElement);\n          this.videoHostOccupiedCallbacks.set(hostElement, onHostOccupied);\n          this.videoHostVacatedCallbacks.set(hostElement, onHostVacated);\n        };\n\n        _proto.renderVideoIntoHostElement = function renderVideoIntoHostElement(hostElement) {\n          var _this5 = this;\n\n          if (this.videoHostElementList.indexOf(hostElement) === -1) {\n            return;\n          }\n\n          cancelAnimationFrame(this.videoHostUpdateRaf);\n          this.videoHostUpdateRaf = requestAnimationFrame(function () {\n            return _this5.updateVideoHostElement(hostElement);\n          });\n        };\n\n        _proto.unregisterVideoHostElement = function unregisterVideoHostElement(hostElement) {\n          this.videoHostElementList = this.videoHostElementList.filter(function (elem) {\n            return elem !== hostElement;\n          });\n          this.videoHostOccupiedCallbacks.delete(hostElement);\n          this.videoHostVacatedCallbacks.delete(hostElement);\n\n          if (this.media.parentNode === hostElement) {\n            this.updateVideoHostElement();\n          }\n        };\n\n        _proto.updateVideoHostElement = function updateVideoHostElement(hostElement) {\n          if (!hostElement) {\n            hostElement = this.videoHostElementList[0] || this.mediaContainer;\n          } else {\n            // move hostElement to front of list\n            this.videoHostElementList = [hostElement].concat(this.videoHostElementList.filter(function (elem) {\n              return elem !== hostElement;\n            }));\n          }\n\n          var playing = !this.media.paused;\n          var oldHostElement = this.media.parentNode;\n\n          if (hostElement === oldHostElement) {\n            return;\n          }\n\n          hostElement.appendChild(this.media); // according to the HTML spec playback should continue, but\n          // some browsers pause the element whenever it is moved around, so\n          // let's make sure playback resumes if that's the case.\n\n          if (playing && this.media.paused) {\n            this.media.play();\n          }\n\n          var onVacated = this.videoHostVacatedCallbacks.get(oldHostElement);\n\n          if (onVacated) {\n            onVacated(this.media);\n          }\n\n          var onOccupied = this.videoHostOccupiedCallbacks.get(hostElement);\n\n          if (onOccupied) {\n            onOccupied(this.media);\n          }\n        };\n\n        _proto.handleMediaPlay = function handleMediaPlay() {\n          this.setState(function (state) {\n            return state.paused === false && state.awaitingPlayAfterTrackLoad === false ? null : {\n              paused: false,\n              awaitingPlayAfterTrackLoad: false\n            };\n          });\n          this.stealMediaSession();\n        };\n\n        _proto.handleMediaPause = function handleMediaPause() {\n          this.setState(function (state) {\n            return state.paused === true ? null : {\n              paused: true\n            };\n          });\n        };\n\n        _proto.handleMediaSrcrequest = function handleMediaSrcrequest(e) {\n          var playlist = this.props.playlist;\n          var sources = utils_getTrackSources(playlist, this.state.activeTrackIndex);\n\n          if (array_find_index_default()(sources, function (s) {\n            return s.src === e.srcRequested;\n          }) !== -1) {\n            // we're good! nothing to update.\n            return;\n          } // looks like 'src' was set from outside our component.\n          // let's see if we can use it.\n\n\n          var newTrackIndex = utils_findTrackIndexByUrl(playlist, e.srcRequested);\n\n          if (newTrackIndex === -1) {\n            Object(console[\"a\"\n            /* logError */\n            ])(\"Source '\" + e.srcRequested + \"' does not exist in the loaded playlist. \" + \"Make sure you've updated the 'playlist' prop to \" + \"PlayerContextProvider before you select this track!\");\n            return;\n          }\n\n          this.selectTrackIndex(newTrackIndex);\n        };\n\n        _proto.handleMediaEnded = function handleMediaEnded() {\n          if (this.state.seekInProgress) {\n            // nothing to do if we're in the middle of a seek\n            // (this can happen if we're in seekMode: immediate)\n            return;\n          }\n\n          clearTimeout(this.gapLengthTimeout);\n          var _this$props2 = this.props,\n              playlist = _this$props2.playlist,\n              loadFirstTrackOnPlaylistComplete = _this$props2.loadFirstTrackOnPlaylistComplete;\n\n          if (!utils_isPlaylistValid(playlist)) {\n            return;\n          }\n\n          var _this$state3 = this.state,\n              cycle = _this$state3.cycle,\n              activeTrackIndex = _this$state3.activeTrackIndex;\n\n          if (!cycle && activeTrackIndex + 1 >= playlist.length) {\n            if (loadFirstTrackOnPlaylistComplete) {\n              this.goToTrack({\n                index: 0,\n                track: playlist[0],\n                shouldPlay: false,\n                shouldForceLoad: true\n              });\n            }\n\n            return;\n          }\n\n          this.gapLengthTimeout = setTimeout(this.forwardSkip, this.props.gapLengthInSeconds * 1000);\n        };\n\n        _proto.handleMediaStalled = function handleMediaStalled() {\n          this.setState(function (state) {\n            return state.stalled === true ? null : {\n              stalled: true\n            };\n          });\n        };\n\n        _proto.handleMediaEmptied = function handleMediaEmptied() {\n          this.setState(function (state) {\n            return state.paused === true ? null : {\n              paused: true\n            };\n          });\n        };\n\n        _proto.handleMediaCanplay = function handleMediaCanplay() {\n          this.setState(function (state) {\n            return state.trackLoading === false ? null : {\n              trackLoading: false\n            };\n          });\n        };\n\n        _proto.handleMediaCanplaythrough = function handleMediaCanplaythrough() {\n          this.setState(function (state) {\n            return state.stalled === false ? null : {\n              stalled: false\n            };\n          });\n        };\n\n        _proto.handleMediaTimeupdate = function handleMediaTimeupdate() {\n          var _this$media = this.media,\n              currentTime = _this$media.currentTime,\n              played = _this$media.played;\n          var _this$props3 = this.props,\n              onTimeUpdate = _this$props3.onTimeUpdate,\n              playlist = _this$props3.playlist;\n          var _this$state4 = this.state,\n              activeTrackIndex = _this$state4.activeTrackIndex,\n              trackLoading = _this$state4.trackLoading;\n\n          if (trackLoading) {\n            // we'll get another time update when the track loads\n            // but for now this helps us avoid unnecessarily\n            // jumping back to currentTime: 0 in the UI while\n            // the track is loading.\n            return;\n          }\n\n          this.setState(function (state) {\n            return {\n              currentTime: currentTime,\n              playedRanges: utils_getTimeRangesArray(played),\n              maxKnownTime: Math.max(state.maxKnownTime, currentTime)\n            };\n          });\n\n          if (onTimeUpdate) {\n            onTimeUpdate({\n              currentTime: currentTime,\n              track: playlist[activeTrackIndex],\n              trackIndex: activeTrackIndex\n            });\n          }\n        };\n\n        _proto.handleMediaLoadeddata = function handleMediaLoadeddata() {\n          if (this.media.currentTime !== this.state.currentTime) {\n            this.media.currentTime = this.state.currentTime;\n          }\n        };\n\n        _proto.handleMediaVolumechange = function handleMediaVolumechange() {\n          var _this$media2 = this.media,\n              volume = _this$media2.volume,\n              muted = _this$media2.muted;\n          this.setState({\n            volume: volume,\n            muted: muted\n          });\n        };\n\n        _proto.handleMediaDurationchange = function handleMediaDurationchange() {\n          var _this6 = this;\n\n          var duration = this.media.duration;\n          var activeTrack = this.props.playlist[this.state.activeTrackIndex];\n\n          if (duration === Infinity) {\n            // This *could* be because we're consuming an unbounded stream.\n            // It could also be because of a weird iOS bug that we want to\n            // try to prevent. See https://github.com/benwiley4000/cassette/issues/355\n            // If we still end up with Infinity duration multiple times for\n            // the same track, we'll assume it's correct.\n            if (activeTrack.isUnboundedStream || activeTrack === this.activeTrackAtLastDurationChange) {\n              this.setState({\n                duration: duration,\n                currentTime: 0\n              });\n              this.media.currentTime = 0;\n            } else {\n              var paused = this.state.paused;\n              this.media.load();\n\n              if (!paused) {\n                // media.currentSrc is updated asynchronously so we should\n                // play async to avoid weird intermediate state issues\n                setTimeout(function () {\n                  _this6.togglePause(false);\n                });\n              }\n            }\n          } else {\n            this.setState({\n              duration: duration\n            });\n          }\n\n          this.activeTrackAtLastDurationChange = activeTrack;\n        };\n\n        _proto.handleMediaProgress = function handleMediaProgress() {\n          this.setState({\n            bufferedRanges: utils_getTimeRangesArray(this.media.buffered),\n            seekableRanges: utils_getTimeRangesArray(this.media.seekable)\n          });\n        };\n\n        _proto.handleMediaLoopchange = function handleMediaLoopchange() {\n          var loop = this.media.loop;\n          this.setState(function (state) {\n            return state.loop === loop ? null : {\n              loop: loop\n            };\n          });\n        };\n\n        _proto.handleMediaRatechange = function handleMediaRatechange() {\n          var playbackRate = this.media.playbackRate;\n          this.setState(function (state) {\n            return state.playbackRate === playbackRate ? null : {\n              playbackRate: playbackRate\n            };\n          });\n        };\n\n        _proto.togglePause = function togglePause(value) {\n          clearTimeout(this.delayTimeout);\n          var pause = typeof value === 'boolean' ? value : !this.state.paused;\n\n          if (pause) {\n            this.media.pause();\n            return;\n          }\n\n          if (!this.media.currentSrc) {\n            return;\n          }\n\n          try {\n            var playPromise = this.media.play();\n\n            if (playPromise && typeof playPromise.catch === 'function') {\n              playPromise.catch(function (err) {\n                // AbortError is pretty much always called because we're skipping\n                // tracks quickly or hitting pause before a track has a chance to\n                // play. It's pretty safe to just ignore these error messages.\n                if (err.name !== 'AbortError') {\n                  return Promise.reject(err);\n                }\n              }).catch(playErrorHandler);\n            }\n          } catch (err) {\n            playErrorHandler(err);\n          }\n        } // assumes playlist is valid - don't call without checking\n        ;\n\n        _proto.goToTrack = function goToTrack(args) {\n          clearTimeout(this.delayTimeout);\n          this.setState(function (prevState) {\n            return getGoToTrackState(PlayerContextProvider_objectSpread({\n              prevState: prevState\n            }, args));\n          });\n        };\n\n        _proto.selectTrackIndex = function selectTrackIndex(index) {\n          var playlist = this.props.playlist;\n\n          if (!utils_isPlaylistValid(playlist)) {\n            return;\n          }\n\n          if (index < 0 || index > playlist.length) {\n            Object(console[\"b\"\n            /* logWarning */\n            ])(\"Playlist index \" + index + \" is out of bounds!\");\n            return;\n          }\n\n          if (this.state.shuffle) {\n            this.shuffler.pickNextItem(index, this.state.activeTrackIndex);\n          }\n\n          this.goToTrack({\n            index: index,\n            track: playlist[index]\n          });\n        };\n\n        _proto.backSkip = function backSkip() {\n          var _this$props4 = this.props,\n              playlist = _this$props4.playlist,\n              stayOnBackSkipThreshold = _this$props4.stayOnBackSkipThreshold;\n          var media = this.media;\n          var _this$state5 = this.state,\n              cycle = _this$state5.cycle,\n              activeTrackIndex = _this$state5.activeTrackIndex,\n              shuffle = _this$state5.shuffle;\n\n          if (!utils_isPlaylistValid(playlist) || media.currentTime >= stayOnBackSkipThreshold || !cycle && activeTrackIndex < 1) {\n            media.currentTime = 0;\n            return;\n          }\n\n          var index;\n\n          if (shuffle) {\n            var previousItem = this.shuffler.findPreviousItem(activeTrackIndex);\n\n            if (previousItem === undefined) {\n              // if we aren't allowing backShuffle then we'll hit a stopping point.\n              media.currentTime = 0;\n              return;\n            }\n\n            index = utils_findTrackIndexByUrl(playlist, previousItem);\n          } else {\n            index = activeTrackIndex - 1;\n\n            if (index < 0) {\n              index = playlist.length - 1;\n            }\n          }\n\n          this.goToTrack({\n            index: index,\n            track: playlist[index],\n            shouldForceLoad: true\n          });\n        };\n\n        _proto.forwardSkip = function forwardSkip() {\n          var playlist = this.props.playlist;\n          var _this$state6 = this.state,\n              cycle = _this$state6.cycle,\n              activeTrackIndex = _this$state6.activeTrackIndex,\n              shuffle = _this$state6.shuffle;\n\n          if (!utils_isPlaylistValid(playlist) || !cycle && activeTrackIndex + 1 >= playlist.length) {\n            return;\n          }\n\n          var index;\n\n          if (shuffle) {\n            index = utils_findTrackIndexByUrl(playlist, this.shuffler.findNextItem(activeTrackIndex));\n          } else {\n            index = activeTrackIndex + 1;\n\n            if (index >= playlist.length) {\n              index = 0;\n            }\n          }\n\n          this.goToTrack({\n            index: index,\n            track: playlist[index],\n            shouldForceLoad: true\n          });\n        };\n\n        _proto.seekPreview = function seekPreview(targetTime) {\n          if (!utils_isPlaylistValid(this.props.playlist)) {\n            return;\n          }\n\n          var baseStateUpdate = {\n            seekPreviewTime: targetTime,\n            seekInProgress: true\n          };\n\n          switch (this.props.seekMode) {\n            case 'paused':\n              this.setState(function (_ref6) {\n                var paused = _ref6.paused,\n                    awaitingResumeOnSeekComplete = _ref6.awaitingResumeOnSeekComplete;\n                return PlayerContextProvider_objectSpread({}, baseStateUpdate, {\n                  awaitingResumeOnSeekComplete: paused ? awaitingResumeOnSeekComplete : true,\n                  currentTime: targetTime\n                });\n              });\n\n              if (!this.state.trackLoading) {\n                this.media.currentTime = targetTime;\n              }\n\n              if (!this.state.paused) {\n                this.togglePause(true);\n              }\n\n              break;\n\n            case 'immediate':\n              this.setState(function (_ref7) {\n                var paused = _ref7.paused,\n                    awaitingResumeOnSeekComplete = _ref7.awaitingResumeOnSeekComplete;\n                return PlayerContextProvider_objectSpread({}, baseStateUpdate, {\n                  awaitingResumeOnSeekComplete: paused ? awaitingResumeOnSeekComplete : true,\n                  currentTime: targetTime\n                });\n              });\n\n              if (!this.state.trackLoading) {\n                this.media.currentTime = targetTime;\n              }\n\n              if (this.state.awaitingResumeOnSeekComplete && !this.media.ended) {\n                // if we earlier encountered an 'ended' state,\n                // un-pausing becomes necessary to resume playback\n                this.togglePause(false);\n              }\n\n              break;\n\n            case 'onrelease':\n              this.setState(baseStateUpdate);\n              break;\n          }\n        };\n\n        _proto.seekComplete = function seekComplete(targetTime) {\n          var _this$state7 = this.state,\n              seekPreviewTime = _this$state7.seekPreviewTime,\n              awaitingResumeOnSeekComplete = _this$state7.awaitingResumeOnSeekComplete,\n              trackLoading = _this$state7.trackLoading;\n          var baseStateUpdate = {\n            seekInProgress: false,\n            awaitingResumeOnSeekComplete: false\n          };\n          var currentTime = typeof targetTime === 'number' ? targetTime : seekPreviewTime;\n\n          if (isNaN(currentTime)) {\n            this.setState(baseStateUpdate);\n            return;\n          }\n\n          this.setState(PlayerContextProvider_objectSpread({}, baseStateUpdate, {\n            /* we'll update currentTime on the media listener hook anyway,\n             * but that might not happen for a bit... so the optimistic update\n             * helps us avoid the progress bar jumping around and confusing the user.\n             * https://github.com/benwiley4000/cassette/issues/209\n             */\n            currentTime: currentTime\n          }));\n\n          if (!trackLoading) {\n            this.media.currentTime = currentTime;\n          }\n\n          if (awaitingResumeOnSeekComplete) {\n            if (this.media.ended) {\n              this.forwardSkip();\n            } else {\n              this.togglePause(false);\n            }\n          }\n        };\n\n        _proto.setVolume = function setVolume(volume, inProgress) {\n          if (inProgress === void 0) {\n            inProgress = true;\n          }\n\n          if (inProgress && !this.state.setVolumeInProgress) {\n            this.setState({\n              setVolumeInProgress: true\n            });\n          }\n\n          var volumeInBounds = utils_convertToNumberWithinIntervalBounds(volume, 0, 1);\n          this.media.muted = volumeInBounds === 0 ? true : false;\n          this.media.volume = volumeInBounds;\n        };\n\n        _proto.setVolumeComplete = function setVolumeComplete(volume) {\n          if (typeof volume === 'number') {\n            this.setVolume(volume, false);\n          }\n\n          this.setState({\n            setVolumeInProgress: false\n          });\n\n          if (!this.media.muted) {\n            this.lastStableVolume = this.media.volume;\n          }\n        };\n\n        _proto.toggleMuted = function toggleMuted(value) {\n          var muted = typeof value === 'boolean' ? value : !this.state.muted;\n          this.media.muted = muted;\n\n          if (!muted) {\n            this.media.volume = this.lastStableVolume;\n          }\n        };\n\n        _proto.toggleShuffle = function toggleShuffle(value) {\n          var shuffle = typeof value === 'boolean' ? value : !this.state.shuffle;\n          this.setState({\n            shuffle: shuffle\n          });\n        };\n\n        _proto.setRepeatStrategy = function setRepeatStrategy(repeatStrategy) {\n          if (repeatStrategyOptions.indexOf(repeatStrategy) === -1) {\n            Object(console[\"b\"\n            /* logWarning */\n            ])('repeatStrategy \"' + repeatStrategy + '\" is not one of: ' + repeatStrategyOptions.split(', ') + '.');\n            return;\n          }\n\n          switch (repeatStrategy) {\n            case 'track':\n              // state update is automatic\n              this.media.loop = true;\n              break;\n\n            case 'playlist':\n              this.setState({\n                loop: false,\n                cycle: true\n              });\n              this.media.loop = false;\n              break;\n\n            case 'none':\n              this.setState({\n                loop: false,\n                cycle: false\n              });\n              this.media.loop = false;\n              break;\n          }\n        };\n\n        _proto.setPlaybackRate = function setPlaybackRate(rate) {\n          this.media.playbackRate = rate;\n        };\n\n        _proto.getControlProps = function getControlProps() {\n          var props = this.props,\n              state = this.state;\n          var playerContext = {\n            playlist: props.playlist,\n            activeTrackIndex: state.activeTrackIndex,\n            trackLoading: state.trackLoading,\n            paused: state.paused,\n            currentTime: state.currentTime,\n            seekPreviewTime: state.seekPreviewTime,\n            seekInProgress: state.seekInProgress,\n            awaitingPlayResume: state.awaitingResumeOnSeekComplete || state.awaitingPlayAfterTrackLoad,\n            duration: state.duration === Infinity ? state.maxKnownTime : state.duration,\n            bufferedRanges: state.bufferedRanges,\n            playedRanges: state.playedRanges,\n            seekableRanges: state.seekableRanges,\n            volume: state.volume,\n            muted: state.muted,\n            shuffle: state.shuffle,\n            stalled: state.stalled,\n            playbackRate: state.playbackRate,\n            mediaCannotPlay: state.mediaCannotPlay,\n            setVolumeInProgress: state.setVolumeInProgress,\n            repeatStrategy: utils_getRepeatStrategy(state.loop, state.cycle),\n            registerVideoHostElement: this.registerVideoHostElement,\n            renderVideoIntoHostElement: this.renderVideoIntoHostElement,\n            unregisterVideoHostElement: this.unregisterVideoHostElement,\n            onTogglePause: this.togglePause,\n            onSelectTrackIndex: this.selectTrackIndex,\n            onBackSkip: this.backSkip,\n            onForwardSkip: this.forwardSkip,\n            onSeekPreview: this.seekPreview,\n            onSeekComplete: this.seekComplete,\n            onSetVolume: this.setVolume,\n            onSetVolumeComplete: this.setVolumeComplete,\n            onToggleMuted: this.toggleMuted,\n            onToggleShuffle: this.toggleShuffle,\n            onSetRepeatStrategy: this.setRepeatStrategy,\n            onSetPlaybackRate: this.setPlaybackRate,\n            reloadActiveTrack: this.reloadActiveTrack\n          };\n\n          if (this.playerContext) {\n            // only update this.playerContext if something has changed\n            var _arr = Object.keys(this.playerContext);\n\n            for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n              var key = _arr[_i3];\n\n              if (playerContext[key] !== this.playerContext[key]) {\n                this.playerContext = playerContext;\n                break;\n              }\n            }\n          } else {\n            // first time - nothing to compare\n            this.playerContext = playerContext;\n          }\n\n          return this.playerContext;\n        };\n\n        _proto.render = function render() {\n          var _this7 = this;\n\n          var playerContext = this.getControlProps();\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"Fragment\"], null, external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(\"div\", {\n            ref: function ref(elem) {\n              return _this7.mediaContainer = elem;\n            },\n            hidden: true\n          }), external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(PlayerContext.Provider, {\n            value: playerContext\n          }, typeof this.props.children === 'function' ? this.props.children(playerContext) : this.props.children));\n        };\n\n        return PlayerContextProvider;\n      }(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"Component\"]);\n\n      PlayerContextProvider_PlayerContextProvider.propTypes = {\n        /**\n         * An array of [`track`](#track) objects to play in order (except when\n         * shuffle mode is turned on)\n         **/\n        playlist: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.arrayOf(PlayerPropTypes_track.isRequired).isRequired,\n\n        /** Set to `true` to play media on player load. Think before doing this. It is\n         * often a bad idea, although it can make sense if your app is expressly made\n         * for media playback and you're resuming playback from the last session.\n         * Note that some platforms will disallow this from happening under many\n         * scenarios, and in these cases, `autoplay` will simply fail gracefully.\n         */\n        autoplay: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool.isRequired,\n\n        /**\n         * If your app uses a custom implementation of the `HTMLMediaElement`, you\n         * can supply your own factory function to return it. This is an advanced\n         * edge case.\n         */\n        createMediaElement: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired,\n\n        /** If you're using `autoplay` but want to wait a few seconds before the\n         * media playback kicks in, you can specify that timeout in second here.\n         */\n        autoplayDelayInSeconds: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /**\n         * Similar to `autoplayDelayInSeconds` but for the pause between tracks\n         * (if you want to evoke the feeling of listening to one of those old CDs with\n         * a negative countdown before it starts, which you never asked for).\n         */\n        gapLengthInSeconds: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /** A [`crossOriginAttribute`](#crossoriginattribute) value */\n        crossOrigin: crossOriginAttribute,\n\n        /** The starting volume (0-1) */\n        defaultVolume: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /** The starting `muted` value (`true` or `false`) */\n        defaultMuted: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool,\n\n        /** The starting [`repeatStrategy`](#repeatstrategy) */\n        defaultRepeatStrategy: PlayerPropTypes_repeatStrategy.isRequired,\n\n        /** Will shuffle mode be active by default? */\n        defaultShuffle: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool,\n\n        /** The starting playback rate (1 is normal, 0.5 is half, 2 is double) */\n        defaultPlaybackRate: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /**\n         * The starting track index (an advanced use case.. normally you should put\n         * the track you want to hear first at the start of the playlist, unless\n         * you are loading an `initialStateSnapshot` which will override this value\n         * anyway\n         */\n        startingTrackIndex: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /**\n         * Set this `false` if the player should rest of the final track when\n         * the playlist has completed. Ignored unless the\n         * current [`repeatStrategy`](#repeatstrategy) is `none`\n         */\n        loadFirstTrackOnPlaylistComplete: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool,\n\n        /** Use this to set the player's [`seekMode`](#seekmode) */\n        seekMode: seekMode.isRequired,\n\n        /**\n         * The default media element behavior is to reset the `playbackRate` to 1\n         * whenever a new source is loaded. Set this prop to `true` to maintain the\n         * same irregular playback rate across multiple tracks.\n         */\n        maintainPlaybackRate: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool.isRequired,\n\n        /**\n         * By default, activating a back skip in shuffle mode will select the previous\n         * track in the shuffled list, but if the current track was the first selected\n         * track, back skip will be disabled. Setting this prop to `true` will\n         * select new arbitrary tracks in the \"past\" if back skip is used beyond\n         * the buffered history.\n         */\n        allowBackShuffle: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool,\n\n        /**\n         * The number of seconds before pressing back skip becomes \"back to\n         * beginning of current track\" rather than \"go to the previous track\"\n         */\n        stayOnBackSkipThreshold: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /**\n         * An array of [`mediaSessionAction`](#mediasessionaction) types to display\n         * in the end users's system UI, when applicable.\n         * It is *not* the same as the `controls` array.\n         */\n        supportedMediaSessionActions: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.arrayOf(mediaSessionAction.isRequired).isRequired,\n\n        /** The number of seconds to seek back or forward when the Media Session API\n         * backseek/forwardseek buttons are activated in the end user's system UI\n         */\n        mediaSessionSeekLengthInSeconds: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.number.isRequired,\n\n        /**\n         * A function called on component mount and component unmount with a reference\n         * to the underlying media element. Generally not recommended for use, but\n         * can be used as an escape hatch for features that aren't well-supported by\n         * Cassette (if you find yourself needing this, you may want to\n         * [open a new issue](https://github.com/benwiley4000/cassette/issues/new)\n         * to talk about adding first-class support for your use case).\n         */\n        mediaElementRef: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func,\n\n        /**\n         * If you're using `onStateSnapshot` to save snapshots of the media player\n         * state as a serializable object, you should pass that restored object here\n         * to preserve the user's state from the previous session\n         */\n        initialStateSnapshot: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.object,\n\n        /**\n         * Called whenever a new state snapshot is generated. The internals of this\n         * snapshot are not documented and may change in a non-major release, so it's\n         * not safe to rely on them directly. Instead, the state snapshot should\n         * be serialized to JSON with `JSON.stringify` and restored later with\n         * `JSON.parse` to be passed as the `initialStateSnapshot` prop\n         */\n        onStateSnapshot: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func,\n\n        /**\n         * A function called whenever the active track is set or updated. Passed an\n         * object with the properties `track`, `trackIndex`, `previousTrack` and\n         * `previousTrackIndex` (these may be `null` or `undefined`)\n         */\n        onActiveTrackUpdate: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func,\n\n        /**\n         * A function called when the media element's `currentTime` attribute has\n         * changed. Passed an object with the properties `currentTime`, `track` and\n         * `trackIndex`\n         */\n        onTimeUpdate: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func,\n\n        /**\n         * A function called when playback of the current track has failed for some\n         * reason. Passed an object with the properties `event`,\n         * `track` and `trackIndex`\n         */\n        onTrackPlaybackFailure: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func,\n\n        /**\n         * A function which receives a [`track`](#track) object (if one is active)\n         * and returns a url pointing to a poster image representing the current\n         * track which should be used in a [`VideoDisplay`](#videodisplay) when the\n         * media content hasn't yet loaded\n         */\n        getPosterImageForTrack: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired,\n\n        /**\n         * A function which receives a [`track`](#track) object (if one is active)\n         * and returns the value for the media element's `title` attribute, which\n         * may be used in iOS to display information about the current track in the\n         * system UI\n         */\n        getMediaTitleAttributeForTrack: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired,\n\n        /**\n         * Either a renderable React node or a render prop function like the\n         * one passed into [`PlayerContextConsumer`](#playercontextconsumer)\n         */\n        children: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOfType([external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.node, external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func]).isRequired\n      };\n      PlayerContextProvider_PlayerContextProvider.defaultProps = {\n        autoplay: false,\n        autoplayDelayInSeconds: 0,\n        createMediaElement: function createMediaElement() {\n          return document.createElement('video');\n        },\n        gapLengthInSeconds: 0,\n        defaultVolume: 1,\n        defaultMuted: false,\n        defaultRepeatStrategy: 'playlist',\n        defaultShuffle: false,\n        defaultPlaybackRate: 1,\n        startingTrackIndex: 0,\n        loadFirstTrackOnPlaylistComplete: true,\n        seekMode: 'immediate',\n        maintainPlaybackRate: false,\n        allowBackShuffle: false,\n        stayOnBackSkipThreshold: 5,\n        supportedMediaSessionActions: ['play', 'pause', 'previoustrack', 'nexttrack'],\n        mediaSessionSeekLengthInSeconds: 10,\n        getPosterImageForTrack: function getPosterImageForTrack(track) {\n          return track && track.artwork ? track.artwork[0].src : '';\n        },\n        getMediaTitleAttributeForTrack: utils_getDisplayText\n      };\n\n      var PlayerContextProvider_PlayerContextGroupMember =\n      /*#__PURE__*/\n      function (_Component2) {\n        _inheritsLoose(PlayerContextGroupMember, _Component2);\n\n        function PlayerContextGroupMember() {\n          return _Component2.apply(this, arguments) || this;\n        }\n\n        var _proto2 = PlayerContextGroupMember.prototype;\n\n        _proto2.componentDidMount = function componentDidMount() {\n          this.props.groupContext.registerMediaElement(this.mediaElement);\n        };\n\n        _proto2.componentWillUnmount = function componentWillUnmount() {\n          // Media element might not exist\n          // (see componentWillUnmount of PlayerContextProvider)\n          if (this.mediaElement) {\n            this.props.groupContext.unregisterMediaElement(this.mediaElement);\n          }\n        };\n\n        _proto2.render = function render() {\n          var _this8 = this;\n\n          var _this$props5 = this.props,\n              groupContext = _this$props5.groupContext,\n              props = _this$props5.props;\n          var _mediaElementRef = props.mediaElementRef,\n              rest = PlayerContextProvider_objectWithoutPropertiesLoose(props, [\"mediaElementRef\"]);\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(PlayerContextProvider_PlayerContextProvider, _extends({}, groupContext.groupProps, rest, {\n            mediaElementRef: function mediaElementRef(ref) {\n              if (_mediaElementRef) {\n                _mediaElementRef(ref);\n              }\n\n              _this8.mediaElement = ref;\n            }\n          }));\n        };\n\n        return PlayerContextGroupMember;\n      }(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"Component\"]);\n\n      PlayerContextProvider_PlayerContextGroupMember.propTypes = {\n        groupContext: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.shape({\n          groupProps: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.object.isRequired,\n          registerMediaElement: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired,\n          unregisterMediaElement: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired\n        }).isRequired\n      };\n\n      function PlayerContextGroupConsumer(props) {\n        return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(GroupContext.Consumer, null, function (groupContext) {\n          if (!groupContext) {\n            return Object(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"createElement\"])(PlayerContextProvider_PlayerContextProvider, props);\n          }\n\n          return Object(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"createElement\"])(PlayerContextProvider_PlayerContextGroupMember, {\n            groupContext: groupContext,\n            props: props\n          });\n        });\n      }\n      /* harmony default export */\n\n\n      var src_PlayerContextProvider = PlayerContextGroupConsumer; // CONCATENATED MODULE: ./src/utils/getReactParentNameStack.js\n      // TODO: support Preact, Inferno, etc.\n\n      function getReactParentNameStack(componentInstance) {\n        var fiber = componentInstance._reactInternalFiber;\n        var parentStack = [];\n        var owner = fiber;\n\n        if (!owner) {\n          return parentStack;\n        }\n\n        while (owner = owner._debugOwner) {\n          if (owner.type.name) {\n            parentStack.push(owner.type.name);\n          }\n        }\n\n        return parentStack;\n      }\n      /* harmony default export */\n\n\n      var utils_getReactParentNameStack = getReactParentNameStack; // CONCATENATED MODULE: ./src/PlayerContextConsumer.js\n\n      function PlayerContextConsumer_inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      var PlayerContextConsumer_PlayerContextConsumer =\n      /*#__PURE__*/\n      function (_PureComponent) {\n        PlayerContextConsumer_inheritsLoose(PlayerContextConsumer, _PureComponent);\n\n        function PlayerContextConsumer() {\n          return _PureComponent.apply(this, arguments) || this;\n        }\n\n        var _proto = PlayerContextConsumer.prototype;\n\n        _proto.render = function render() {\n          var _this$props = this.props,\n              children = _this$props.children,\n              filterList = _this$props.filterList;\n\n          if (!filterList) {\n            if (!this.warnedAboutFilterList) {\n              var warning = \"\\n          Please pass the filterList prop to PlayerContextConsumer in order\\n          to avoid unnecessarily frequent re-renders, e.g.\\n\\n          const filterList = ['paused', 'onTogglePause'];\\n          // ...\\n          <PlayerContextConsumer filterList={filterList}>\\n            {({ paused, onTogglePause }) => {\\n              return <div>{/* ... */}</div>;\\n            }}\\n          </PlayerContextConsumer>\\n        \";\n\n              for (var _iterator = utils_getReactParentNameStack(this), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n                var _ref;\n\n                if (_isArray) {\n                  if (_i >= _iterator.length) break;\n                  _ref = _iterator[_i++];\n                } else {\n                  _i = _iterator.next();\n                  if (_i.done) break;\n                  _ref = _i.value;\n                }\n\n                var parentName = _ref;\n                warning += \"\\n            Rendered by \" + parentName;\n              }\n\n              Object(console[\"b\"\n              /* logWarning */\n              ])(warning);\n              this.warnedAboutFilterList = true;\n            }\n\n            return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(PlayerContext.Consumer, null, children);\n          }\n\n          var flags = PlayerContext.__cassetteGetObservedBits(filterList);\n\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(PlayerContext.Consumer, {\n            unstable_observedBits: flags\n          }, function (playerContext) {\n            var usedContext = {};\n\n            for (var _iterator2 = filterList, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n              var _ref2;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref2 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref2 = _i2.value;\n              }\n\n              var name = _ref2;\n\n              if (playerContext.hasOwnProperty(name)) {\n                usedContext[name] = playerContext[name];\n              }\n            }\n\n            return children(usedContext);\n          });\n        };\n\n        return PlayerContextConsumer;\n      }(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"PureComponent\"]);\n\n      PlayerContextConsumer_PlayerContextConsumer.propTypes = {\n        /**\n         * A [render prop](https://reactjs.org/docs/render-props.html) function\n         * which receives as its argument an object with the latest values of the\n         * keys specified in the `filterList` prop (if you forget `filterList`, you\n         * will get all the `playerContext` values and a warning in the console)\n         */\n        children: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func.isRequired,\n\n        /**\n         * A full list of `playerContext` values which will need to be consumed.\n         * Similar to the prop name array passed to\n         * [`playerContextFilter`](#playercontextfilter), but only made up of values\n         * found in [`playerContext`](#playercontext).\n         *\n         */\n        filterList: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.arrayOf(external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.string.isRequired)\n      };\n      /* harmony default export */\n\n      var src_PlayerContextConsumer = PlayerContextConsumer_PlayerContextConsumer; // CONCATENATED MODULE: ./src/PlayerContextGroup.js\n\n      function PlayerContextGroup_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            PlayerContextGroup_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function PlayerContextGroup_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function PlayerContextGroup_inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      function PlayerContextGroup_assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n      /**\n       * A wrapper which can be used to share configuration among multiple descendant [`PlayerContextProvider`](#playercontextprovider) instances as well as prevent multiple media elements from playing audio simultaneously\n       */\n\n\n      var PlayerContextGroup_PlayerContextGroup =\n      /*#__PURE__*/\n      function (_Component) {\n        PlayerContextGroup_inheritsLoose(PlayerContextGroup, _Component);\n\n        function PlayerContextGroup(props) {\n          var _this;\n\n          _this = _Component.call(this, props) || this;\n          _this.registerMediaElement = _this.registerMediaElement.bind(PlayerContextGroup_assertThisInitialized(PlayerContextGroup_assertThisInitialized(_this)));\n          _this.unregisterMediaElement = _this.unregisterMediaElement.bind(PlayerContextGroup_assertThisInitialized(PlayerContextGroup_assertThisInitialized(_this)));\n          _this.enforceOneMediaSourceOnly = _this.enforceOneMediaSourceOnly.bind(PlayerContextGroup_assertThisInitialized(PlayerContextGroup_assertThisInitialized(_this)));\n          _this.mediaElements = [];\n          return _this;\n        }\n\n        var _proto = PlayerContextGroup.prototype;\n\n        _proto.registerMediaElement = function registerMediaElement(elem) {\n          this.mediaElements = this.mediaElements.concat(elem);\n          elem.addEventListener('play', this.enforceOneMediaSourceOnly, true);\n          elem.addEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n        };\n\n        _proto.unregisterMediaElement = function unregisterMediaElement(elem) {\n          this.mediaElements = this.mediaElements.filter(function (element) {\n            return elem !== element;\n          });\n          elem.removeEventListener('play', this.enforceOneMediaSourceOnly, true);\n          elem.removeEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n        };\n\n        _proto.enforceOneMediaSourceOnly = function enforceOneMediaSourceOnly(e) {\n          var mediaElement = e.target;\n          var paused = mediaElement.paused,\n              muted = mediaElement.muted;\n\n          if (paused || muted) {\n            return;\n          }\n\n          for (var _iterator = this.mediaElements, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var element = _ref;\n\n            if (element !== mediaElement && !element.muted) {\n              element.pause();\n            }\n          }\n        };\n\n        _proto.render = function render() {\n          var _this2 = this;\n\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(GroupContext.Consumer, null, function (groupContext) {\n            var value = groupContext ? PlayerContextGroup_objectSpread({}, groupContext, {\n              groupProps: PlayerContextGroup_objectSpread({}, groupContext.groupProps, _this2.props)\n            }) : {\n              groupProps: _this2.props,\n              registerMediaElement: _this2.registerMediaElement,\n              unregisterMediaElement: _this2.unregisterMediaElement\n            };\n            return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(GroupContext.Provider, {\n              value: value\n            }, _this2.props.children);\n          });\n        };\n\n        return PlayerContextGroup;\n      }(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"Component\"]);\n\n      PlayerContextGroup_PlayerContextGroup.propTypes = {\n        children: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.node.isRequired\n      };\n      /* harmony default export */\n\n      var src_PlayerContextGroup = PlayerContextGroup_PlayerContextGroup; // CONCATENATED MODULE: ./src/FullscreenContext.js\n\n      /* harmony default export */\n\n      var FullscreenContext = Object(createSingleGlobalContext[\"a\"\n      /* default */\n      ])({\n        displayName: 'FullscreenContext',\n        defaultValue: {\n          fullscreen: false,\n          requestFullscreen: function requestFullscreen() {\n            Object(console[\"b\"\n            /* logWarning */\n            ])('Fullscreen request ignored since there is no ' + 'FullscreenContextProvider ancestor.');\n          },\n          requestExitFullscreen: function requestExitFullscreen() {\n            Object(console[\"b\"\n            /* logWarning */\n            ])('Exit fullscreen request ignored since there is no ' + 'FullscreenContextProvider ancestor.');\n          }\n        },\n        keysWillUpdate: ['fullscreen']\n      }); // CONCATENATED MODULE: ./src/FullscreenContextProvider.js\n\n      function FullscreenContextProvider_inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      function FullscreenContextProvider_assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      var fullscreenStyle = {\n        width: '100%',\n        height: '100%'\n      };\n      /**\n       * Wraps an area which should be fullscreen-able\n       */\n\n      var FullscreenContextProvider_FullscreenContextProvider =\n      /*#__PURE__*/\n      function (_PureComponent) {\n        FullscreenContextProvider_inheritsLoose(FullscreenContextProvider, _PureComponent);\n\n        function FullscreenContextProvider(props) {\n          var _this;\n\n          _this = _PureComponent.call(this, props) || this;\n          _this.state = {\n            fullscreen: false\n          };\n          _this.requestFullscreen = _this.requestFullscreen.bind(FullscreenContextProvider_assertThisInitialized(FullscreenContextProvider_assertThisInitialized(_this)));\n          _this.requestExitFullscreen = _this.requestExitFullscreen.bind(FullscreenContextProvider_assertThisInitialized(FullscreenContextProvider_assertThisInitialized(_this)));\n          _this.handleFullscreenChange = _this.handleFullscreenChange.bind(FullscreenContextProvider_assertThisInitialized(FullscreenContextProvider_assertThisInitialized(_this)));\n          _this.fullscreenElement = null;\n          return _this;\n        }\n\n        var _proto = FullscreenContextProvider.prototype;\n\n        _proto.componentDidMount = function componentDidMount() {\n          document.addEventListener('fullscreenchange', this.handleFullscreenChange);\n          document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);\n          document.addEventListener('mozfullscreenchange', this.handleFullscreenChange);\n          document.addEventListener('msfullscreenchange', this.handleFullscreenChange);\n        };\n\n        _proto.componentWillUnmount = function componentWillUnmount() {\n          document.removeEventListener('fullscreenchange', this.handleFullscreenChange);\n          document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);\n          document.removeEventListener('mozfullscreenchange', this.handleFullscreenChange);\n          document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);\n        };\n\n        _proto.requestFullscreen = function requestFullscreen() {\n          if (!this.props.fullscreenEnabled) {\n            return;\n          }\n\n          if (this.fullscreenElement.requestFullscreen) {\n            this.fullscreenElement.requestFullscreen();\n          } else if (this.fullscreenElement.webkitRequestFullscreen) {\n            this.fullscreenElement.webkitRequestFullscreen();\n          } else if (this.fullscreenElement.mozRequestFullscreen) {\n            this.fullscreenElement.mozRequestFullScreen();\n          } else if (this.fullscreenElement.msRequestFullscreen) {\n            this.fullscreenElement.msRequestFullscreen();\n          }\n        };\n\n        _proto.requestExitFullscreen = function requestExitFullscreen() {\n          if (document.exitFullscreen) {\n            document.exitFullscreen();\n          } else if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n          } else if (document.webkitCancelFullScreen) {\n            document.webkitCancelFullScreen();\n          } else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n          } else if (document.msExitFullscreen) {\n            document.mozExitFullscreen();\n          }\n        };\n\n        _proto.handleFullscreenChange = function handleFullscreenChange() {\n          var documentFullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n          this.setState({\n            fullscreen: documentFullscreenElement === this.fullscreenElement\n          });\n        };\n\n        _proto.getFullscreenContext = function getFullscreenContext() {\n          var fullscreenContext = {\n            fullscreen: this.state.fullscreen,\n            requestFullscreen: this.requestFullscreen,\n            requestExitFullscreen: this.requestExitFullscreen\n          };\n\n          if (this.fullscreenContext && fullscreenContext.fullscreen === this.fullscreenContext.fullscreen) {\n            // no change\n            return this.fullscreenContext;\n          }\n\n          return this.fullscreenContext = fullscreenContext;\n        };\n\n        _proto.render = function render() {\n          var _this2 = this;\n\n          var fullscreenContext = this.getFullscreenContext();\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(\"div\", {\n            ref: function ref(elem) {\n              return _this2.fullscreenElement = elem;\n            },\n            style: this.state.fullscreen ? fullscreenStyle : undefined\n          }, external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(FullscreenContext.Provider, {\n            value: fullscreenContext\n          }, typeof this.props.children === 'function' ? this.props.children(fullscreenContext) : this.props.children));\n        };\n\n        return FullscreenContextProvider;\n      }(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"PureComponent\"]);\n\n      FullscreenContextProvider_FullscreenContextProvider.propTypes = {\n        /** If set `false`, disables fullscreen for the wrapped area */\n        fullscreenEnabled: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.bool.isRequired,\n\n        /**\n         * Either a renderable React node or a render prop function like the\n         * one passed into [`FullscreenContextConsumer`](#fullscreencontextconsumer)\n         */\n        children: external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.oneOfType([external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.node, external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default.a.func]).isRequired\n      };\n      FullscreenContextProvider_FullscreenContextProvider.defaultProps = {\n        fullscreenEnabled: true\n      };\n      /* harmony default export */\n\n      var src_FullscreenContextProvider = FullscreenContextProvider_FullscreenContextProvider; // CONCATENATED MODULE: ./src/playerContextFilter.js\n\n      function playerContextFilter_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            playerContextFilter_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function playerContextFilter_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function playerContextFilter(component, contextPropNames) {\n        var warned = {};\n        var childName = component.displayName || component.name;\n\n        var flags = PlayerContext.__cassetteGetObservedBits(contextPropNames);\n\n        function PlayerContextFilter(props) {\n          return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(FullscreenContext.Consumer, null, function (fullscreenContext) {\n            return external_root_React_commonjs_react_commonjs2_react_amd_react_default.a.createElement(PlayerContext.Consumer, {\n              unstable_observedBits: flags\n            }, function (playerContext) {\n              var childProps = playerContextFilter_objectSpread({}, props);\n\n              for (var _iterator = contextPropNames, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n                var _ref;\n\n                if (_isArray) {\n                  if (_i >= _iterator.length) break;\n                  _ref = _iterator[_i++];\n                } else {\n                  _i = _iterator.next();\n                  if (_i.done) break;\n                  _ref = _i.value;\n                }\n\n                var propName = _ref;\n\n                if (playerContext.hasOwnProperty(propName)) {\n                  childProps[propName] = playerContext[propName];\n                } else if (fullscreenContext.hasOwnProperty(propName)) {\n                  childProps[propName] = fullscreenContext[propName];\n                } else if (!warned[propName]) {\n                  Object(console[\"b\"\n                  /* logWarning */\n                  ])(\"Prop '\" + propName + \"' for component \" + childName + ' not found in playerContext or fullscreenContext.');\n                  warned[propName] = true;\n                }\n              }\n\n              return Object(external_root_React_commonjs_react_commonjs2_react_amd_react_[\"createElement\"])(component, childProps);\n            });\n          });\n        }\n\n        if (childName) {\n          PlayerContextFilter.displayName = \"PlayerContextFilter(\" + childName + \")\";\n        }\n\n        return PlayerContextFilter;\n      }\n      /* harmony default export */\n\n\n      var src_playerContextFilter = playerContextFilter; // CONCATENATED MODULE: ./src/index.js\n\n      /* harmony export (binding) */\n\n      __webpack_require__.d(__webpack_exports__, \"FullscreenContextConsumer\", function () {\n        return FullscreenContextConsumer;\n      });\n      /* harmony export (binding) */\n\n\n      __webpack_require__.d(__webpack_exports__, \"donotuse_PlayerContext\", function () {\n        return donotuse_PlayerContext;\n      });\n      /* harmony export (binding) */\n\n\n      __webpack_require__.d(__webpack_exports__, \"donotuse_FullscreenContext\", function () {\n        return donotuse_FullscreenContext;\n      });\n      /* concated harmony reexport PlayerContextProvider */\n\n\n      __webpack_require__.d(__webpack_exports__, \"PlayerContextProvider\", function () {\n        return src_PlayerContextProvider;\n      });\n      /* concated harmony reexport PlayerContextConsumer */\n\n\n      __webpack_require__.d(__webpack_exports__, \"PlayerContextConsumer\", function () {\n        return src_PlayerContextConsumer;\n      });\n      /* concated harmony reexport PlayerContextGroup */\n\n\n      __webpack_require__.d(__webpack_exports__, \"PlayerContextGroup\", function () {\n        return src_PlayerContextGroup;\n      });\n      /* concated harmony reexport FullscreenContextProvider */\n\n\n      __webpack_require__.d(__webpack_exports__, \"FullscreenContextProvider\", function () {\n        return src_FullscreenContextProvider;\n      });\n      /* concated harmony reexport playerContextFilter */\n\n\n      __webpack_require__.d(__webpack_exports__, \"playerContextFilter\", function () {\n        return src_playerContextFilter;\n      });\n      /* concated harmony reexport PlayerPropTypes */\n\n\n      __webpack_require__.d(__webpack_exports__, \"PlayerPropTypes\", function () {\n        return PlayerPropTypes_namespaceObject;\n      });\n      /* concated harmony reexport logError */\n\n\n      __webpack_require__.d(__webpack_exports__, \"logError\", function () {\n        return console[\"a\"\n        /* logError */\n        ];\n      });\n      /* concated harmony reexport logWarning */\n\n\n      __webpack_require__.d(__webpack_exports__, \"logWarning\", function () {\n        return console[\"b\"\n        /* logWarning */\n        ];\n      });\n      /* concated harmony reexport convertToNumberWithinIntervalBounds */\n\n\n      __webpack_require__.d(__webpack_exports__, \"convertToNumberWithinIntervalBounds\", function () {\n        return utils_convertToNumberWithinIntervalBounds;\n      });\n      /* concated harmony reexport isPlaylistValid */\n\n\n      __webpack_require__.d(__webpack_exports__, \"isPlaylistValid\", function () {\n        return utils_isPlaylistValid;\n      });\n      /* concated harmony reexport getDisplayText */\n\n\n      __webpack_require__.d(__webpack_exports__, \"getDisplayText\", function () {\n        return utils_getDisplayText;\n      });\n      /* concated harmony reexport repeatStrategyOptions */\n\n\n      __webpack_require__.d(__webpack_exports__, \"repeatStrategyOptions\", function () {\n        return repeatStrategyOptions;\n      });\n\n      var FullscreenContextConsumer = FullscreenContext.Consumer; // undocumented exports\n\n      var donotuse_PlayerContext = PlayerContext;\n      var donotuse_FullscreenContext = FullscreenContext;\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}