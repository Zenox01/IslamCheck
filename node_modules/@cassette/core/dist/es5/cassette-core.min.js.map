{"version":3,"sources":["webpack://cassetteCore/webpack/universalModuleDefinition","webpack://cassetteCore/webpack/bootstrap","webpack://cassetteCore/external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}","webpack://cassetteCore/external {\"root\":\"PropTypes\",\"commonjs\":\"prop-types\",\"commonjs2\":\"prop-types\",\"amd\":\"prop-types\"}","webpack://cassetteCore/./src/utils/console.js","webpack://cassetteCore/./src/utils/createSingleGlobalContext.js","webpack://cassetteCore/./node_modules/array-find-index/index.js","webpack://cassetteCore/(webpack)/buildin/global.js","webpack://cassetteCore/./src/PlayerContext.js","webpack://cassetteCore/./src/GroupContext.js","webpack://cassetteCore/./src/constants.js","webpack://cassetteCore/./src/PlayerPropTypes.js","webpack://cassetteCore/./src/factories/createCustomMediaElement.js","webpack://cassetteCore/./src/utils/ShuffleManager.js","webpack://cassetteCore/./src/utils/isPlaylistValid.js","webpack://cassetteCore/./src/utils/getTrackSources.js","webpack://cassetteCore/./src/utils/findTrackIndexByUrl.js","webpack://cassetteCore/./src/utils/snapshot.js","webpack://cassetteCore/./src/utils/getSourceList.js","webpack://cassetteCore/./src/utils/getTimeRangesArray.js","webpack://cassetteCore/./src/utils/getRepeatStrategy.js","webpack://cassetteCore/./src/utils/convertToNumberWithinIntervalBounds.js","webpack://cassetteCore/./src/utils/getDisplayText.js","webpack://cassetteCore/./src/utils/parseTimeString.js","webpack://cassetteCore/./src/utils/getInitialDuration.js","webpack://cassetteCore/./src/PlayerContextProvider.js","webpack://cassetteCore/./src/utils/getReactParentNameStack.js","webpack://cassetteCore/./src/PlayerContextConsumer.js","webpack://cassetteCore/./src/PlayerContextGroup.js","webpack://cassetteCore/./src/FullscreenContext.js","webpack://cassetteCore/./src/FullscreenContextProvider.js","webpack://cassetteCore/./src/playerContextFilter.js","webpack://cassetteCore/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","logWarning","log","console","logError","error","warn","packageVersion","version","_global","window","global","__cassette_contexts__","_ref","displayName","_ref$defaultValue","defaultValue","keysWillUpdate","ExistingContext","_console__WEBPACK_IMPORTED_MODULE_1__","flags","_iterator","_isArray","Array","isArray","_i","iterator","_ref2","length","next","done","Context","react__WEBPACK_IMPORTED_MODULE_0__","prev","mask","_iterator2","_isArray2","_i2","_ref3","__cassetteGetObservedBits","keys","observedBits","_iterator3","_isArray3","_i3","_ref4","arr","predicate","ctx","findIndex","TypeError","list","len","g","Function","eval","e","PlayerContext","createSingleGlobalContext","GroupContext","repeatStrategyOptions","requiredOnlyUnlessHasProp","propType","altPropName","warnedAboutDefiningBoth","props","propName","componentName","_len","arguments","rest","_key","isRequired","apply","concat","Error","controlKeyword","external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default","a","oneOf","control","oneOfType","func","crossOriginAttribute","PlayerPropTypes_repeatStrategy","mediaSource","shape","src","string","type","mediaSessionAction","mediaSessionArtwork","sizes","PlayerPropTypes_track","url","sources","arrayOf","title","artist","album","artwork","duration","number","startingTime","isUnboundedStream","bool","meta","seekMode","loopchange","srcrequest","factories_createCustomMediaElement","media","MutationObserver","dispatchEvent","Event","observe","attributes","attributeFilter","currentSrc","set","srcRequested","_goForward","forwardStack","backStack","currentItem","item","push","pop","_findNextItem","allowMore","indexOf","_allItemsMatch","nextItem","Math","floor","random","undefined","utils_ShuffleManager","ShuffleManager","options","_list","_forwardStack","_backStack","_currentItem","_allowBackShuffle","Boolean","allowBackShuffle","_proto","findNextItem","currentIndex","setCurrentIndex","findPreviousItem","pickNextItem","index","setList","setOptions","_arr","clear","utils_isPlaylistValid","playlist","blankSources","utils_getTrackSources","_playlist$index","utils_findTrackIndexByUrl","array_find_index_default","track","source","veryLongKey","versionKey","migrations","oldSnapshot","_objectSpread2","__unstable__","_objectSpread","_objectWithoutPropertiesLoose","utils_getSourceList","map","_","utils_getTimeRangesArray","timeRangesObj","timeRangesArray","start","end","utils_getRepeatStrategy","loop","cycle","utils_convertToNumberWithinIntervalBounds","min","max","Infinity","utils_getDisplayText","utils_parseTimeString","str","seconds","factor","times","split","slice","parseInt","utils_getInitialDuration","playErrorHandler","err","warningMessage","Date","toLocaleTimeString","supportableMediaSessionActions","defaultState","paused","currentTime","seekPreviewTime","seekInProgress","awaitingResumeOnSeekComplete","awaitingPlayAfterTrackLoad","bufferedRanges","playedRanges","seekableRanges","stalled","shouldRequestPlayOnNextUpdate","mediaCannotPlay","maxKnownTime","getGoToTrackState","prevState","_ref$shouldPlay","shouldPlay","_ref$shouldForceLoad","shouldForceLoad","isNewTrack","activeTrackIndex","shouldLoadAsNew","trackLoading","awaitingForceLoad","PlayerContextProvider_PlayerContextProvider","_Component","PlayerContextProvider","_this","startingTrackIndex","playlistIsValid","initialStateSnapshot","restoredStateFromSnapshot","_restoredStateFromSna","snapshot","_migratedSnapshot$ver","reduce","migration","volume","muted","shuffle","playbackRate","activeTrackSrc","restoredStateValues","awaitingPlay","useCurrentTime","newTrackIndex","restoreStateFromSnapshot","JSON","stringify","state","PlayerContextProvider_objectSpread","defaultVolume","defaultMuted","defaultRepeatStrategy","defaultShuffle","defaultPlaybackRate","setVolumeInProgress","autoplay","__playlist__","lastStableVolume","shuffler","videoHostElementList","videoHostOccupiedCallbacks","Map","videoHostVacatedCallbacks","handleTrackPlaybackFailure","_assertThisInitialized","handlePlayerOnlineAfterFailure","togglePause","selectTrackIndex","forwardSkip","backSkip","seekPreview","seekComplete","setVolume","setVolumeComplete","toggleMuted","toggleShuffle","setRepeatStrategy","setPlaybackRate","registerVideoHostElement","renderVideoIntoHostElement","unregisterVideoHostElement","updateVideoHostElement","handleMediaPlay","handleMediaPause","handleMediaSrcrequest","handleMediaEnded","handleMediaEmptied","handleMediaStalled","handleMediaCanplaythrough","handleMediaCanplay","handleMediaTimeupdate","handleMediaLoadeddata","handleMediaVolumechange","handleMediaDurationchange","handleMediaProgress","handleMediaLoopchange","handleMediaRatechange","_inheritsLoose","componentDidMount","_this2","createMediaElement","_this$props","crossOrigin","autoplayDelayInSeconds","mediaElementRef","getPosterImageForTrack","getMediaTitleAttributeForTrack","onActiveTrackUpdate","_this$state","setAttribute","addEventListener","setMediaElementSources","mediaContainer","appendChild","setState","delayTimeout","setTimeout","trackIndex","previousTrack","previousTrackIndex","getDerivedStateFromProps","nextProps","newPlaylist","baseNewState","prevSources","currentSources","componentDidUpdate","prevProps","_this3","newSources","prevTrack","newTrack","removeEventListener","stealMediaSession","clearTimeout","snapshotUpdateTimeout","onStateSnapshot","getStateSnapshot","componentWillUnmount","querySelectorAll","gapLengthTimeout","_this4","MediaSession","navigator","mediaSession","metadata","MediaMetadata","action","supportedMediaSessionActions","seekLength","mediaSessionSeekLengthInSeconds","forEach","handler","setActionHandler","firstChild","removeChild","sourceElement","document","createElement","load","reloadActiveTrack","_temp","_ref4$shouldPlay","_this$state2","goToTrack","event","target","code","onLine","onTrackPlaybackFailure","hostElement","_ref5","onHostOccupied","onHostVacated","_this5","cancelAnimationFrame","videoHostUpdateRaf","requestAnimationFrame","filter","elem","delete","parentNode","playing","oldHostElement","play","onVacated","onOccupied","_this$props2","loadFirstTrackOnPlaylistComplete","_this$state3","gapLengthInSeconds","_this$media","played","_this$props3","onTimeUpdate","_this$state4","_this$media2","_this6","activeTrack","activeTrackAtLastDurationChange","buffered","seekable","pause","playPromise","catch","Promise","reject","args","_this$props4","stayOnBackSkipThreshold","_this$state5","previousItem","_this$state6","targetTime","baseStateUpdate","_ref6","_ref7","ended","_this$state7","isNaN","inProgress","volumeInBounds","repeatStrategy","rate","getControlProps","playerContext","awaitingPlayResume","onTogglePause","onSelectTrackIndex","onBackSkip","onForwardSkip","onSeekPreview","onSeekComplete","onSetVolume","onSetVolumeComplete","onToggleMuted","onToggleShuffle","onSetRepeatStrategy","onSetPlaybackRate","render","_this7","external_root_React_commonjs_react_commonjs2_react_amd_react_default","external_root_React_commonjs_react_commonjs2_react_amd_react_","ref","hidden","Provider","children","defaultProps","maintainPlaybackRate","PlayerContextProvider_PlayerContextGroupMember","_Component2","PlayerContextGroupMember","_proto2","groupContext","registerMediaElement","mediaElement","unregisterMediaElement","_this8","_this$props5","PlayerContextProvider_objectWithoutPropertiesLoose","_extends","groupProps","src_PlayerContextProvider","Consumer","utils_getReactParentNameStack","componentInstance","parentStack","owner","_reactInternalFiber","_debugOwner","src_PlayerContextConsumer","filterList","warnedAboutFilterList","warning","unstable_observedBits","usedContext","src_PlayerContextGroup","PlayerContextGroup","PlayerContextGroup_assertThisInitialized","enforceOneMediaSourceOnly","mediaElements","PlayerContextGroup_inheritsLoose","element","PlayerContextGroup_objectSpread","FullscreenContext","fullscreen","requestFullscreen","requestExitFullscreen","fullscreenStyle","width","height","FullscreenContextProvider_FullscreenContextProvider","_PureComponent","FullscreenContextProvider","FullscreenContextProvider_assertThisInitialized","handleFullscreenChange","fullscreenElement","FullscreenContextProvider_inheritsLoose","fullscreenEnabled","webkitRequestFullscreen","mozRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","webkitCancelFullScreen","mozCancelFullScreen","msExitFullscreen","mozExitFullscreen","documentFullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","getFullscreenContext","fullscreenContext","style","src_FullscreenContextProvider","src_playerContextFilter","component","contextPropNames","warned","childName","PlayerContextFilter","childProps","playerContextFilter_objectSpread","FullscreenContextConsumer","donotuse_PlayerContext","donotuse_FullscreenContext"],"mappings":"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","file":"es5/cassette-core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cassetteCore\"] = factory(require(\"react\"), require(\"prop-types\"));\n\telse\n\t\troot[\"cassetteCore\"] = factory(root[\"React\"], root[\"PropTypes\"]);\n})((typeof self !== \"undefined\" ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","/* eslint-disable no-console */\n\nconst log = console.log.bind(console);\n\nexport const logError = console.error ? console.error.bind(console) : log;\nexport const logWarning = console.warn ? console.warn.bind(console) : log;\n","import { createContext } from 'react';\n\nimport { logWarning } from './console';\n\nconst packageVersion = require('../../package.json').version;\n\nconst _global = typeof window === 'undefined' ? global : window;\n_global.__cassette_contexts__ = _global.__cassette_contexts__ || {};\n\nfunction createSingleGlobalContext({\n  displayName,\n  defaultValue = null,\n  keysWillUpdate\n}) {\n  const ExistingContext = _global.__cassette_contexts__[displayName];\n  if (ExistingContext) {\n    if (ExistingContext.packageVersion !== packageVersion) {\n      logWarning(\n        `Warning: multiple versions of ${displayName} from the @cassette/core` +\n          ` package have been loaded. v${packageVersion} will be ignored and` +\n          ` v${ExistingContext.packageVersion} will be used instead.`\n      );\n    }\n    return ExistingContext;\n  }\n  // inspired by:\n  // https://github.com/philosaf/observed-bits/blob/master/src/index.js\n  const flags = {};\n  let i = 0;\n  for (const key of keysWillUpdate) {\n    flags[key] = 1 << i++;\n  }\n  const Context = createContext(defaultValue, function getChangedBits(\n    prev,\n    next\n  ) {\n    let mask = 0;\n    for (const key of keysWillUpdate) {\n      if (prev[key] !== next[key]) {\n        mask |= flags[key];\n      }\n    }\n    return mask;\n  });\n  Context.__cassetteGetObservedBits = keys => {\n    let observedBits = 0;\n    for (const key of keys) {\n      observedBits |= flags[key];\n    }\n    return observedBits;\n  };\n  Context.displayName = displayName;\n  Context.packageVersion = packageVersion;\n  _global.__cassette_contexts__[displayName] = Context;\n  return Context;\n}\n\nexport default createSingleGlobalContext;\n","'use strict';\nmodule.exports = function (arr, predicate, ctx) {\n\tif (typeof Array.prototype.findIndex === 'function') {\n\t\treturn arr.findIndex(predicate, ctx);\n\t}\n\n\tif (typeof predicate !== 'function') {\n\t\tthrow new TypeError('predicate must be a function');\n\t}\n\n\tvar list = Object(arr);\n\tvar len = list.length;\n\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif (predicate.call(ctx, list[i], i, list)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\n\n// TODO: test to make sure context contents stay in sync with\n// enumerated list here\n\nexport default createSingleGlobalContext({\n  displayName: 'PlayerContext',\n  keysWillUpdate: [\n    'playlist',\n    'activeTrackIndex',\n    'trackLoading',\n    'paused',\n    'currentTime',\n    'seekPreviewTime',\n    'seekInProgress',\n    'awaitingPlayResume',\n    'duration',\n    'bufferedRanges',\n    'playedRanges',\n    'seekableRanges',\n    'volume',\n    'muted',\n    'shuffle',\n    'stalled',\n    'playbackRate',\n    'setVolumeInProgress',\n    'repeatStrategy',\n    'mediaCannotPlay'\n  ]\n});\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\n\nexport default createSingleGlobalContext({\n  displayName: 'GroupContext',\n  keysWillUpdate: ['groupProps']\n});\n","export const repeatStrategyOptions = ['none', 'playlist', 'track'];\nexport const MEDIA_ERR_NETWORK = 2;\n","import PropTypes from 'prop-types';\n\nimport { repeatStrategyOptions } from './constants';\nimport { logWarning } from './utils/console';\n\nfunction requiredOnlyUnlessHasProp(propType, altPropName) {\n  let warnedAboutDefiningBoth = false;\n  function validate(props, propName, componentName, ...rest) {\n    if (propName in props) {\n      if (!warnedAboutDefiningBoth && altPropName in props) {\n        logWarning(\n          `Do not define both the '${propName}' and '${altPropName}' props.`\n        );\n        warnedAboutDefiningBoth = true;\n      }\n      return propType.isRequired(props, propName, componentName, ...rest);\n    }\n    if (!(altPropName in props)) {\n      return new Error(\n        `If the '${altPropName}' prop is not defined, '${propName}' must be.`\n      );\n    }\n  }\n  return validate;\n}\n\nexport const controlKeyword = PropTypes.oneOf([\n  'playpause',\n  'backskip',\n  'forwardskip',\n  'volume',\n  'mute',\n  'repeat',\n  'shuffle',\n  'progress',\n  'progressdisplay',\n  'fullscreen',\n  'spacer'\n]);\n\nexport const control = PropTypes.oneOfType([PropTypes.func, controlKeyword]);\n\nexport const crossOriginAttribute = PropTypes.oneOf([\n  'anonymous',\n  'use-credentials'\n]);\n\nexport const repeatStrategy = PropTypes.oneOf(repeatStrategyOptions);\n\nexport const mediaSource = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired\n});\n\nexport const mediaSessionAction = PropTypes.oneOf([\n  'play',\n  'pause',\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n]);\n\nexport const mediaSessionArtwork = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  sizes: PropTypes.string,\n  type: PropTypes.string\n});\n\nexport const track = PropTypes.shape({\n  url: requiredOnlyUnlessHasProp(PropTypes.string, 'sources'),\n  sources: requiredOnlyUnlessHasProp(\n    PropTypes.arrayOf(mediaSource.isRequired),\n    'url'\n  ),\n  title: PropTypes.string.isRequired,\n  artist: PropTypes.string,\n  album: PropTypes.string,\n  artwork: PropTypes.arrayOf(mediaSessionArtwork.isRequired),\n  duration: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  startingTime: PropTypes.number,\n  isUnboundedStream: PropTypes.bool,\n  meta: PropTypes.object\n});\n\nexport const seekMode = PropTypes.oneOf(['paused', 'immediate', 'onrelease']);\n","const loopchange = 'loopchange';\nconst srcrequest = 'srcrequest';\n\nfunction createCustomMediaElement(media) {\n  new MutationObserver(() => {\n    media.dispatchEvent(new Event(loopchange));\n  }).observe(media, {\n    attributes: true,\n    attributeFilter: ['loop']\n  });\n  // Don't let the media src property get modified directly.\n  // Instead, when it does get set, dispatch an event to be\n  // handled in a way that doesn't conflict with the loaded\n  // playlist.\n  Object.defineProperty(media, 'src', {\n    get: () => media.currentSrc,\n    set: src => {\n      const e = new Event(srcrequest);\n      e.srcRequested = src;\n      media.dispatchEvent(e);\n    }\n  });\n  return media;\n}\n\nexport default createCustomMediaElement;\n","/* ShuffleManager\n *\n * Manages navigation throughout a list which is:\n * - Sourced from another provided list\n * - In random order (except to avoid consecutive duplicates)\n * - Extended endlessly on-the-fly, as needed\n * - Able to have future history overwritten by non-random choices\n * - Able to swap source lists and maintain shuffle order for common members\n */\n\nexport class ShuffleManager {\n  constructor(list, options = {}) {\n    this._list = list;\n    this._forwardStack = [];\n    this._backStack = [];\n    this._currentItem = undefined;\n\n    this._allowBackShuffle = Boolean(options.allowBackShuffle);\n  }\n\n  findNextItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._forwardStack,\n      this._backStack,\n      this._currentItem,\n      true\n    );\n    return this._currentItem;\n  }\n\n  findPreviousItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._backStack,\n      this._forwardStack,\n      this._currentItem,\n      this._allowBackShuffle\n    );\n    return this._currentItem;\n  }\n\n  pickNextItem(index, currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    if (this._list[index] === undefined) {\n      return undefined;\n    }\n    if (this._currentItem !== undefined) {\n      this._backStack.push(this._currentItem);\n    }\n    this._forwardStack.length = 0;\n    this._currentItem = this._list[index];\n    return this._currentItem;\n  }\n\n  setList(list) {\n    this._list = list;\n  }\n\n  setOptions(options) {\n    for (const o of Object.keys(options)) {\n      switch (o) {\n        case 'allowBackShuffle':\n          this[`_${o}`] = Boolean(options[o]);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  setCurrentIndex(currentIndex) {\n    const item = this._list[currentIndex];\n    if (this._currentItem !== item) {\n      this.clear();\n      this._currentItem = item;\n    }\n  }\n\n  clear() {\n    this._forwardStack.length = 0;\n    this._backStack.length = 0;\n    this._currentItem = undefined;\n  }\n}\n\nfunction _goForward(n, forwardStack, backStack, currentItem) {\n  let item = currentItem;\n  for (let i = 0; i < n; i++) {\n    if (!forwardStack.length) {\n      // rollback before erroring (note stack reversal)\n      _goForward(i, backStack, forwardStack, item);\n      throw `Moving ${n} places was not possible!`;\n    }\n    backStack.push(item);\n    item = forwardStack.pop();\n  }\n  return item;\n}\n\nfunction _allItemsMatch(list, item) {\n  if (!list.length) {\n    return false;\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (item !== list[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _findNextItem(list, forwardStack, backStack, currentItem, allowMore) {\n  let item = currentItem;\n  if (!list.length) {\n    return undefined;\n  }\n  for (let i = 1; i <= forwardStack.length; i++) {\n    if (list.indexOf(forwardStack[forwardStack.length - i]) !== -1) {\n      return _goForward(i, forwardStack, backStack, item);\n    }\n  }\n  if (!allowMore) {\n    return undefined;\n  }\n  if (_allItemsMatch(list, item)) {\n    // we can serve this as our \"next\" item but we\n    // won't modify our history since it's the same.\n    return item;\n  }\n  let nextItem;\n  do {\n    nextItem = list[Math.floor(Math.random() * list.length)];\n  } while (item === nextItem || nextItem === undefined);\n  // if we're skipping items that aren't in our current list we may\n  // have some items in our forwardStack - make sure we move to the front.\n  item = _goForward(forwardStack.length, forwardStack, backStack, item);\n  if (item !== undefined) {\n    backStack.push(item);\n  }\n  return nextItem;\n}\n\nexport default ShuffleManager;\n","function isPlaylistValid(playlist) {\n  return Boolean(playlist && playlist.length);\n}\n\nexport default isPlaylistValid;\n","import isPlaylistValid from './isPlaylistValid';\n\nconst blankSources = [{ src: '' }];\n\nfunction getTrackSources(playlist, index) {\n  if (!isPlaylistValid(playlist)) {\n    return blankSources;\n  }\n  const { sources, url } = playlist[index];\n  if (sources) {\n    return sources.length ? sources : blankSources;\n  }\n  return [{ src: url }];\n}\n\nexport default getTrackSources;\n","import arrayFindIndex from 'array-find-index';\n\nfunction findTrackIndexByUrl(playlist, url) {\n  return arrayFindIndex(playlist, track => {\n    if (track.sources) {\n      return arrayFindIndex(track.sources, source => source.src === url) !== -1;\n    }\n    return track.url && url === track.url;\n  });\n}\n\nexport default findTrackIndexByUrl;\n","import isPlaylistValid from './isPlaylistValid';\nimport getTrackSources from './getTrackSources';\nimport findTrackIndexByUrl from './findTrackIndexByUrl';\n\nconst veryLongKey =\n  '__highly_unstable_snapshot_internals_which_will_break_your_app_if_you_use_them_directly__';\nconst versionKey = '__cassette_snapshot_version__';\n\n// IMPORTANT: new migrations *must* always be added to the end since\n// the tracked snapshot version is based on the migration index.\n// If there is a crash-inducing bug in an existing migration, it can be patched\n// in-place, but it should never be removed from the migrations array.\nconst migrations = [\n  oldSnapshot => {\n    const { __unstable__, ...rest } = oldSnapshot;\n    return {\n      ...rest,\n      [veryLongKey]: __unstable__\n    };\n  }\n];\n\nexport function getStateSnapshot(state) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    duration,\n    __playlist__\n  } = state;\n  return {\n    [versionKey]: migrations.length,\n    [veryLongKey]: {\n      paused,\n      // currentTime can't be restored for unbounded live streams\n      currentTime: duration === Infinity ? 0 : currentTime,\n      activeTrackIndex,\n      volume,\n      muted,\n      loop,\n      cycle,\n      shuffle,\n      playbackRate,\n      activeTrackSrc: isPlaylistValid(__playlist__)\n        ? getTrackSources(__playlist__, activeTrackIndex)[0].src\n        : null\n    }\n  };\n}\n\nexport function restoreStateFromSnapshot(snapshot, props) {\n  const migratedSnapshot = migrations\n    .slice(snapshot[versionKey] || 0)\n    .reduce((oldSnapshot, migration) => migration(oldSnapshot), snapshot);\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    activeTrackSrc\n  } = migratedSnapshot[veryLongKey];\n  const restoredStateValues = {};\n  if (isPlaylistValid(props.playlist) && typeof paused === 'boolean') {\n    // using awaitingPlay instead of paused triggers an animation\n    restoredStateValues.awaitingPlay = !paused;\n  }\n  if (typeof volume === 'number' && volume >= 0 && volume <= 1) {\n    restoredStateValues.volume = volume;\n  }\n  if (typeof muted === 'boolean') {\n    restoredStateValues.muted = muted;\n  }\n  if (typeof loop === 'boolean') {\n    restoredStateValues.loop = loop;\n  }\n  if (typeof cycle === 'boolean') {\n    restoredStateValues.cycle = cycle;\n  }\n  if (typeof shuffle === 'boolean') {\n    restoredStateValues.shuffle = shuffle;\n  }\n  if (typeof playbackRate === 'number') {\n    restoredStateValues.playbackRate = playbackRate;\n  }\n  let useCurrentTime = false;\n  if (\n    typeof activeTrackSrc === 'string' &&\n    typeof activeTrackIndex === 'number' &&\n    activeTrackIndex >= 0\n  ) {\n    // let's try staying on the same track index\n    const currentSrc =\n      props.playlist[activeTrackIndex] &&\n      getTrackSources(props.playlist, activeTrackIndex)[0].src;\n    if (currentSrc && activeTrackSrc === currentSrc) {\n      restoredStateValues.activeTrackIndex = activeTrackIndex;\n      useCurrentTime = true;\n    } else {\n      /* if the track we were playing before is in the new playlist,\n       * update the activeTrackIndex.\n       */\n      const newTrackIndex = findTrackIndexByUrl(props.playlist, activeTrackSrc);\n      if (newTrackIndex !== -1) {\n        restoredStateValues.activeTrackIndex = newTrackIndex;\n        useCurrentTime = true;\n      }\n    }\n  }\n  if (useCurrentTime && typeof currentTime === 'number' && currentTime >= 0) {\n    restoredStateValues.currentTime = currentTime;\n  }\n  return restoredStateValues;\n}\n","import getTrackSources from './getTrackSources';\n\n// collapses playlist into flat list containing\n// the first source url for each track\nfunction getSourceList(playlist) {\n  return (playlist || []).map((_, i) => getTrackSources(playlist, i)[0].src);\n}\n\nexport default getSourceList;\n","function getTimeRangesArray(timeRangesObj) {\n  const timeRangesArray = Array(timeRangesObj.length);\n  for (let i = 0; i < timeRangesObj.length; i++) {\n    timeRangesArray[i] = {\n      start: timeRangesObj.start(i),\n      end: timeRangesObj.end(i)\n    };\n  }\n  return timeRangesArray;\n}\n\nexport default getTimeRangesArray;\n","function getRepeatStrategy(loop, cycle) {\n  if (loop) {\n    return 'track';\n  }\n  if (cycle) {\n    return 'playlist';\n  }\n  return 'none';\n}\n\nexport default getRepeatStrategy;\n","function convertToNumberWithinIntervalBounds(number, min, max) {\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n  return Math.max(min, Math.min(number, max));\n}\n\nexport default convertToNumberWithinIntervalBounds;\n","function getDisplayText(track) {\n  if (!track) {\n    return '';\n  }\n  if (track.title && track.artist) {\n    return `${track.artist} - ${track.title}`;\n  }\n  return track.title || track.artist || track.album || '';\n}\n\nexport default getDisplayText;\n","function parseTimeString(str) {\n  let seconds = 0;\n  let factor = 1;\n  const times = str.split(':').slice(-3);\n  while (times.length > 0) {\n    seconds += factor * parseInt(times.pop(), 10);\n    factor *= 60;\n  }\n  return seconds;\n}\n\nexport default parseTimeString;\n","import parseTimeString from './parseTimeString';\n\nfunction getInitialDuration(track) {\n  let duration = 0;\n  if (track.duration) {\n    if (typeof track.duration === 'string') {\n      duration = parseTimeString(track.duration);\n    } else {\n      duration = track.duration;\n    }\n  }\n  return duration;\n}\n\nexport default getInitialDuration;\n","import React, { Component, Fragment, createElement } from 'react';\nimport PropTypes from 'prop-types';\nimport arrayFindIndex from 'array-find-index';\n\nimport PlayerContext from './PlayerContext';\nimport GroupContext from './GroupContext';\nimport * as PlayerPropTypes from './PlayerPropTypes';\nimport createCustomMediaElement from './factories/createCustomMediaElement';\nimport ShuffleManager from './utils/ShuffleManager';\nimport { getStateSnapshot, restoreStateFromSnapshot } from './utils/snapshot';\nimport getSourceList from './utils/getSourceList';\nimport getTrackSources from './utils/getTrackSources';\nimport getTimeRangesArray from './utils/getTimeRangesArray';\nimport findTrackIndexByUrl from './utils/findTrackIndexByUrl';\nimport isPlaylistValid from './utils/isPlaylistValid';\nimport getRepeatStrategy from './utils/getRepeatStrategy';\nimport convertToNumberWithinIntervalBounds from './utils/convertToNumberWithinIntervalBounds';\nimport { logError, logWarning } from './utils/console';\nimport getDisplayText from './utils/getDisplayText';\nimport getInitialDuration from './utils/getInitialDuration';\nimport { repeatStrategyOptions, MEDIA_ERR_NETWORK } from './constants';\n\nfunction playErrorHandler(err) {\n  logError(err);\n  if (err.name === 'NotAllowedError') {\n    const warningMessage =\n      'Media playback failed at ' +\n      new Date().toLocaleTimeString() +\n      '! (Perhaps autoplay is disabled in this browser.)';\n    logWarning(warningMessage);\n  }\n}\n\n// Existing Media Session API implementations have default handlers\n// for play/pause, and may yield unexpected behavior if custom\n// play/pause handlers are defined - so let's leave them be.\nconst supportableMediaSessionActions = [\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n];\n\nconst defaultState = {\n  // indicates whether media player should be paused\n  paused: true,\n  // elapsed time for active track, in seconds\n  currentTime: 0,\n  // The most recent targeted time, in seconds, for seek preview\n  seekPreviewTime: 0,\n  /* true if the user is currently dragging the mouse\n   * to seek a new track position\n   */\n  seekInProgress: false,\n  /* true if media was playing when seek previewing began,\n   * it was paused, and it should be resumed on seek\n   * complete\n   */\n  awaitingResumeOnSeekComplete: false,\n  // true if media will play once new track has loaded\n  awaitingPlayAfterTrackLoad: false,\n  // the duration in seconds of the loaded track\n  duration: 0,\n  // array describing the buffered ranges in the loaded track\n  bufferedRanges: [],\n  // array describing the already-played ranges in the loaded track\n  playedRanges: [],\n  // array describing the seekable ranges in the loaded track\n  seekableRanges: [],\n  // true if the media is currently stalled pending data buffering\n  stalled: false,\n  // true if the active track should play on the next componentDidUpdate\n  shouldRequestPlayOnNextUpdate: false,\n  /* true if an error occurs while fetching the active track media data\n   * or if its type is not a supported media format\n   */\n  mediaCannotPlay: false,\n  // maximum currentTime since the current track has been playing\n  maxKnownTime: 0\n};\n\n// assumes playlist is valid\nfunction getGoToTrackState({\n  prevState,\n  index,\n  track,\n  shouldPlay = true,\n  shouldForceLoad = false,\n  startingTime\n}) {\n  const isNewTrack = prevState.activeTrackIndex !== index;\n  const shouldLoadAsNew = Boolean(isNewTrack || shouldForceLoad);\n  const currentTime = startingTime || track.startingTime || 0;\n  return {\n    duration: getInitialDuration(track),\n    activeTrackIndex: index,\n    trackLoading: shouldLoadAsNew,\n    mediaCannotPlay: prevState.mediaCannotPlay && !shouldLoadAsNew,\n    currentTime: convertToNumberWithinIntervalBounds(currentTime, 0),\n    loop: shouldLoadAsNew ? false : prevState.loop,\n    shouldRequestPlayOnNextUpdate: Boolean(shouldPlay),\n    awaitingPlayAfterTrackLoad: Boolean(shouldPlay),\n    awaitingForceLoad: Boolean(shouldForceLoad),\n    maxKnownTime: shouldLoadAsNew ? 0 : prevState.maxKnownTime\n  };\n}\n\n/**\n * Wraps an area which shares a common [`playerContext`](#playercontext)\n */\nexport class PlayerContextProvider extends Component {\n  constructor(props) {\n    super(props);\n    let currentTime = 0;\n    let activeTrackIndex = convertToNumberWithinIntervalBounds(\n      props.startingTrackIndex,\n      0\n    );\n    const playlistIsValid = isPlaylistValid(props.playlist);\n    if (playlistIsValid && props.playlist[activeTrackIndex]) {\n      currentTime = props.playlist[activeTrackIndex].startingTime || 0;\n    }\n    const { initialStateSnapshot } = props;\n    let restoredStateFromSnapshot = {};\n    if (initialStateSnapshot) {\n      try {\n        restoredStateFromSnapshot = restoreStateFromSnapshot(\n          initialStateSnapshot,\n          props\n        );\n        const {\n          activeTrackIndex: a,\n          currentTime: c\n        } = restoredStateFromSnapshot;\n        if (typeof a === 'number') {\n          activeTrackIndex = a;\n        }\n        if (typeof c === 'number') {\n          currentTime = c;\n        }\n      } catch (err) {\n        logWarning(err);\n        logWarning('Loading Cassette state from snapshot failed.');\n        logWarning(\n          `Failed snapshot:\\n${JSON.stringify(initialStateSnapshot, null, 2)}`\n        );\n      }\n    }\n    this.state = {\n      ...defaultState,\n      // index matching requested track (whether track has loaded or not)\n      activeTrackIndex,\n      // whether we're waiting on loading metadata for the active track\n      trackLoading: isPlaylistValid(props.playlist),\n      // the current timestamp on the active track in seconds\n      currentTime: convertToNumberWithinIntervalBounds(currentTime, 0),\n      // the latest volume of the media, between 0 and 1.\n      volume: convertToNumberWithinIntervalBounds(props.defaultVolume, 0, 1),\n      // true if the media has been muted\n      muted: props.defaultMuted,\n      // whether to loop the active track\n      loop: props.defaultRepeatStrategy === 'track',\n      // true if playlist should continue at start after completion\n      cycle: props.defaultRepeatStrategy === 'playlist',\n      // whether to randomly pick next track from playlist after one finishes\n      shuffle: props.defaultShuffle,\n      // Rate at which media should be played. 1.0 is normal speed.\n      playbackRate: props.defaultPlaybackRate,\n      // true if user is currently dragging mouse to change the volume\n      setVolumeInProgress: false,\n      // initialize shouldRequestPlayOnNextUpdate from autoplay prop\n      shouldRequestPlayOnNextUpdate: props.autoplay && playlistIsValid,\n      awaitingForceLoad: false,\n      // duration might be set on track object\n      duration: getInitialDuration(\n        playlistIsValid && props.playlist[activeTrackIndex]\n      ),\n      // playlist prop copied to state (for getDerivedStateFromProps)\n      __playlist__: props.playlist,\n      // load overrides from previously-captured state snapshot\n      ...restoredStateFromSnapshot\n    };\n\n    // volume at last time we were unmuted and not actively setting volume\n    this.lastStableVolume = this.state.volume;\n\n    // used to keep track of play history when we are shuffling\n    this.shuffler = new ShuffleManager(getSourceList(props.playlist), {\n      allowBackShuffle: props.allowBackShuffle\n    });\n\n    // html media element used for playback\n    this.media = null;\n\n    this.videoHostElementList = [];\n    this.videoHostOccupiedCallbacks = new Map();\n    this.videoHostVacatedCallbacks = new Map();\n\n    // bind internal methods\n    this.handleTrackPlaybackFailure = this.handleTrackPlaybackFailure.bind(\n      this\n    );\n    this.handlePlayerOnlineAfterFailure = this.handlePlayerOnlineAfterFailure.bind(\n      this\n    );\n\n    // bind callback methods to pass to descendant elements\n    this.togglePause = this.togglePause.bind(this);\n    this.selectTrackIndex = this.selectTrackIndex.bind(this);\n    this.forwardSkip = this.forwardSkip.bind(this);\n    this.backSkip = this.backSkip.bind(this);\n    this.seekPreview = this.seekPreview.bind(this);\n    this.seekComplete = this.seekComplete.bind(this);\n    this.setVolume = this.setVolume.bind(this);\n    this.setVolumeComplete = this.setVolumeComplete.bind(this);\n    this.toggleMuted = this.toggleMuted.bind(this);\n    this.toggleShuffle = this.toggleShuffle.bind(this);\n    this.setRepeatStrategy = this.setRepeatStrategy.bind(this);\n    this.setPlaybackRate = this.setPlaybackRate.bind(this);\n    this.registerVideoHostElement = this.registerVideoHostElement.bind(this);\n    this.renderVideoIntoHostElement = this.renderVideoIntoHostElement.bind(\n      this\n    );\n    this.unregisterVideoHostElement = this.unregisterVideoHostElement.bind(\n      this\n    );\n    this.updateVideoHostElement = this.updateVideoHostElement.bind(this);\n\n    // bind media event handlers\n    this.handleMediaPlay = this.handleMediaPlay.bind(this);\n    this.handleMediaPause = this.handleMediaPause.bind(this);\n    this.handleMediaSrcrequest = this.handleMediaSrcrequest.bind(this);\n    this.handleMediaEnded = this.handleMediaEnded.bind(this);\n    this.handleMediaEmptied = this.handleMediaEmptied.bind(this);\n    this.handleMediaStalled = this.handleMediaStalled.bind(this);\n    this.handleMediaCanplaythrough = this.handleMediaCanplaythrough.bind(this);\n    this.handleMediaCanplay = this.handleMediaCanplay.bind(this);\n    this.handleMediaTimeupdate = this.handleMediaTimeupdate.bind(this);\n    this.handleMediaLoadeddata = this.handleMediaLoadeddata.bind(this);\n    this.handleMediaVolumechange = this.handleMediaVolumechange.bind(this);\n    this.handleMediaDurationchange = this.handleMediaDurationchange.bind(this);\n    this.handleMediaProgress = this.handleMediaProgress.bind(this);\n    this.handleMediaLoopchange = this.handleMediaLoopchange.bind(this);\n    this.handleMediaRatechange = this.handleMediaRatechange.bind(this);\n  }\n\n  componentDidMount() {\n    const media = (this.media = createCustomMediaElement(\n      this.props.createMediaElement()\n    ));\n\n    const {\n      defaultPlaybackRate,\n      crossOrigin,\n      playlist,\n      autoplayDelayInSeconds,\n      mediaElementRef,\n      getPosterImageForTrack,\n      getMediaTitleAttributeForTrack,\n      onActiveTrackUpdate\n    } = this.props;\n    const {\n      volume,\n      muted,\n      playbackRate,\n      loop,\n      activeTrackIndex,\n      shouldRequestPlayOnNextUpdate\n    } = this.state;\n\n    // initialize media properties\n    // We used to set currentTime here.. now waiting for loadeddata.\n    // This avoids an issue where some browsers ignore or delay currentTime\n    // updates when in the HAVE_NOTHING state.\n    media.defaultPlaybackRate = defaultPlaybackRate;\n    if (crossOrigin) {\n      media.crossOrigin = crossOrigin;\n    }\n    media.volume = volume;\n    media.muted = muted;\n    media.playbackRate = playbackRate;\n    media.loop = loop;\n    media.setAttribute('playsinline', '');\n    media.setAttribute('webkit-playsinline', '');\n    media.setAttribute('preload', 'metadata');\n    media.setAttribute(\n      'poster',\n      getPosterImageForTrack(playlist[activeTrackIndex])\n    );\n    media.setAttribute(\n      'title',\n      getMediaTitleAttributeForTrack(playlist[activeTrackIndex])\n    );\n    // add listeners for media events\n    media.addEventListener('play', this.handleMediaPlay);\n    media.addEventListener('pause', this.handleMediaPause);\n    media.addEventListener('ended', this.handleMediaEnded);\n    media.addEventListener('stalled', this.handleMediaStalled);\n    media.addEventListener('emptied', this.handleMediaEmptied);\n    media.addEventListener('canplay', this.handleMediaCanplay);\n    media.addEventListener('canplaythrough', this.handleMediaCanplaythrough);\n    media.addEventListener('timeupdate', this.handleMediaTimeupdate);\n    media.addEventListener('loadeddata', this.handleMediaLoadeddata);\n    media.addEventListener('volumechange', this.handleMediaVolumechange);\n    media.addEventListener('durationchange', this.handleMediaDurationchange);\n    media.addEventListener('progress', this.handleMediaProgress);\n    media.addEventListener('ratechange', this.handleMediaRatechange);\n    media.addEventListener('error', this.handleTrackPlaybackFailure);\n    // add listeners for special events\n    media.addEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.addEventListener('loopchange', this.handleMediaLoopchange);\n\n    // set source elements for current track\n    this.setMediaElementSources();\n\n    // initially mount media element in the hidden container (this may change)\n    this.mediaContainer.appendChild(media);\n\n    if (shouldRequestPlayOnNextUpdate) {\n      this.setState({\n        shouldRequestPlayOnNextUpdate: false\n      });\n      this.delayTimeout = setTimeout(() => {\n        this.togglePause(false);\n      }, autoplayDelayInSeconds * 1000);\n    }\n\n    if (mediaElementRef) {\n      mediaElementRef(media);\n    }\n\n    if (onActiveTrackUpdate) {\n      onActiveTrackUpdate({\n        track: playlist[activeTrackIndex],\n        trackIndex: activeTrackIndex,\n        previousTrack: null,\n        previousTrackIndex: null\n      });\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const newPlaylist = nextProps.playlist;\n\n    if (newPlaylist === prevState.__playlist__) {\n      // reference comparison is equal so we'll\n      // assume the playlist is unchanged.\n      return null;\n    }\n\n    const baseNewState = {\n      __playlist__: newPlaylist\n    };\n\n    // check if the new playlist is invalid\n    if (!isPlaylistValid(newPlaylist)) {\n      return {\n        ...defaultState,\n        ...baseNewState,\n        activeTrackIndex: 0,\n        trackLoading: false\n      };\n    }\n\n    // check if the activeTrackIndex doesn't need to be updated\n    const prevSources = getTrackSources(\n      prevState.__playlist__,\n      prevState.activeTrackIndex\n    );\n\n    if (newPlaylist[prevState.activeTrackIndex]) {\n      // the sources if we stay on the same track index\n      const currentSources = getTrackSources(\n        newPlaylist,\n        prevState.activeTrackIndex\n      );\n      // non-comprehensive but probably accurate check\n      if (prevSources[0].src === currentSources[0].src) {\n        // our active track index already matches\n        return baseNewState;\n      }\n    }\n\n    /* if the track we're already playing is in the new playlist, update the\n     * activeTrackIndex.\n     */\n    const newTrackIndex = findTrackIndexByUrl(newPlaylist, prevSources[0].src);\n    if (newTrackIndex !== -1) {\n      return {\n        ...baseNewState,\n        activeTrackIndex: newTrackIndex\n      };\n    }\n\n    // if not, then load the first track in the new playlist, and pause.\n    return {\n      ...baseNewState,\n      ...getGoToTrackState({\n        prevState,\n        track: newPlaylist[0],\n        index: 0,\n        shouldPlay: false,\n        shouldForceLoad: true\n      }),\n      mediaCannotPlay: false,\n      awaitingPlayAfterTrackLoad: false\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n    this.media.crossOrigin = this.props.crossOrigin;\n\n    this.shuffler.setList(getSourceList(this.props.playlist));\n    this.shuffler.setOptions({\n      allowBackShuffle: this.props.allowBackShuffle\n    });\n\n    const prevSources = getTrackSources(\n      prevProps.playlist,\n      prevState.activeTrackIndex\n    );\n    const newSources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    const prevTrack = prevProps.playlist[prevState.activeTrackIndex];\n    const newTrack = this.props.playlist[this.state.activeTrackIndex];\n    if (\n      this.state.awaitingForceLoad ||\n      prevSources[0].src !== newSources[0].src\n    ) {\n      this.setMediaElementSources();\n      this.media.setAttribute(\n        'poster',\n        this.props.getPosterImageForTrack(newTrack)\n      );\n      this.media.setAttribute(\n        'title',\n        this.props.getMediaTitleAttributeForTrack(newTrack)\n      );\n      this.setState({\n        awaitingForceLoad: false\n      });\n      if (!this.state.shuffle) {\n        // after toggling off shuffle, we defer clearing the shuffle\n        // history until we actually change tracks - if the user quickly\n        // toggles  shuffle off then back on again, we don't want to have\n        // lost our history.\n        this.shuffler.clear();\n      }\n      // If track changes before player is back online, the previous track\n      // shouldn't be reloaded.\n      window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n    }\n\n    if (this.props.onActiveTrackUpdate && prevTrack !== newTrack) {\n      this.props.onActiveTrackUpdate({\n        track: newTrack,\n        trackIndex: this.state.activeTrackIndex,\n        previousTrack: prevTrack,\n        previousTrackIndex: prevState.activeTrackIndex\n      });\n    }\n\n    if (prevProps !== this.props && !this.media.paused) {\n      // update running media session based on new props\n      this.stealMediaSession();\n    }\n\n    if (this.state.shouldRequestPlayOnNextUpdate) {\n      this.setState({\n        shouldRequestPlayOnNextUpdate: false\n      });\n      // media.currentSrc is updated asynchronously so we should\n      // play async to avoid weird intermediate state issues\n      setTimeout(() => {\n        this.togglePause(false);\n      });\n    }\n\n    clearTimeout(this.snapshotUpdateTimeout);\n    this.snapshotUpdateTimeout = setTimeout(() => {\n      if (this.props.onStateSnapshot) {\n        this.props.onStateSnapshot(getStateSnapshot(this.state));\n      }\n    }, 100);\n  }\n\n  componentWillUnmount() {\n    const { media } = this;\n    // Media element creation will have failed if MutationObserver isn't\n    // supported by the browser. The parent might use an Error Boundary\n    // to display a fallback and so we try to avoid triggering *additional*\n    // errors while the component unmounts.\n    if (media) {\n      // remove listeners for media events\n      media.removeEventListener('play', this.handleMediaPlay);\n      media.removeEventListener('pause', this.handleMediaPause);\n      media.removeEventListener('ended', this.handleMediaEnded);\n      media.removeEventListener('stalled', this.handleMediaStalled);\n      media.removeEventListener('emptied', this.handleMediaEmptied);\n      media.removeEventListener(\n        'canplaythrough',\n        this.handleMediaCanplaythrough\n      );\n      media.removeEventListener('canplay', this.handleMediaCanplay);\n      media.removeEventListener('timeupdate', this.handleMediaTimeupdate);\n      media.removeEventListener('loadeddata', this.handleMediaLoadeddata);\n      media.removeEventListener('volumechange', this.handleMediaVolumechange);\n      media.removeEventListener(\n        'durationchange',\n        this.handleMediaDurationchange\n      );\n      media.removeEventListener('progress', this.handleMediaProgress);\n      media.removeEventListener('ratechange', this.handleMediaRatechange);\n      media.removeEventListener('error', this.handleTrackPlaybackFailure);\n      // remove special event listeners on the media element\n      media.removeEventListener('srcrequest', this.handleMediaSrcrequest);\n      media.removeEventListener('loopchange', this.handleMediaLoopchange);\n\n      const sourceElements = media.querySelectorAll('source');\n      for (const sourceElement of sourceElements) {\n        sourceElement.removeEventListener(\n          'error',\n          this.handleTrackPlaybackFailure\n        );\n      }\n    }\n    clearTimeout(this.gapLengthTimeout);\n    clearTimeout(this.delayTimeout);\n    window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n  }\n\n  stealMediaSession() {\n    if (\n      // eslint-disable-next-line no-undef\n      !(window.MediaSession && navigator.mediaSession instanceof MediaSession)\n    ) {\n      return;\n    }\n    // eslint-disable-next-line no-undef\n    navigator.mediaSession.metadata = new MediaMetadata(\n      this.props.playlist[this.state.activeTrackIndex]\n    );\n    supportableMediaSessionActions\n      .map(action => {\n        if (this.props.supportedMediaSessionActions.indexOf(action) === -1) {\n          return null;\n        }\n        const seekLength = this.props.mediaSessionSeekLengthInSeconds;\n        switch (action) {\n          case 'play':\n            return this.togglePause.bind(this, false);\n          case 'pause':\n            return this.togglePause.bind(this, true);\n          case 'previoustrack':\n            return this.backSkip;\n          case 'nexttrack':\n            return this.forwardSkip;\n          case 'seekbackward':\n            return () => (this.media.currentTime -= seekLength);\n          case 'seekforward':\n            return () => (this.media.currentTime += seekLength);\n          default:\n            return undefined;\n        }\n      })\n      .forEach((handler, i) => {\n        navigator.mediaSession.setActionHandler(\n          supportableMediaSessionActions[i],\n          handler\n        );\n      });\n  }\n\n  setMediaElementSources() {\n    // remove current sources\n    const { playlist } = this.props;\n    let firstChild;\n    while ((firstChild = this.media.firstChild)) {\n      this.media.removeChild(firstChild);\n    }\n    if (isPlaylistValid(playlist)) {\n      const sources = getTrackSources(playlist, this.state.activeTrackIndex);\n      // add new sources\n      for (const source of sources) {\n        const sourceElement = document.createElement('source');\n        sourceElement.src = source.src;\n        if (source.type) {\n          sourceElement.type = source.type;\n        }\n        sourceElement.addEventListener(\n          'error',\n          this.handleTrackPlaybackFailure\n        );\n        this.media.appendChild(sourceElement);\n      }\n    }\n    // cancel playback and re-scan new sources\n    this.media.load();\n  }\n\n  reloadActiveTrack({ shouldPlay = false } = {}) {\n    const { playlist } = this.props;\n    const { activeTrackIndex, paused, currentTime } = this.state;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    this.goToTrack({\n      track: playlist[activeTrackIndex],\n      shouldForceLoad: true,\n      shouldPlay: shouldPlay || !paused,\n      startingTime: currentTime,\n      index: activeTrackIndex\n    });\n  }\n\n  handlePlayerOnlineAfterFailure() {\n    this.reloadActiveTrack();\n    window.removeEventListener('online', this.handlePlayerOnlineAfterFailure);\n  }\n\n  handleTrackPlaybackFailure(event) {\n    const shouldPlay = !this.state.paused;\n    this.setState({\n      mediaCannotPlay: true\n    });\n    const error = event.target.error;\n    // If there's a network error, the current track should be reloaded\n    // in order to recover from the error state the player is in.\n    if (\n      event.target === this.media &&\n      error &&\n      error.code === MEDIA_ERR_NETWORK\n    ) {\n      if (window.navigator.onLine) {\n        this.reloadActiveTrack({ shouldPlay });\n      } else {\n        window.addEventListener('online', this.handlePlayerOnlineAfterFailure);\n      }\n    }\n    if (this.props.onTrackPlaybackFailure) {\n      this.props.onTrackPlaybackFailure({\n        track: this.props.playlist[this.state.activeTrackIndex],\n        trackIndex: this.state.activeTrackIndex,\n        event\n      });\n    }\n  }\n\n  registerVideoHostElement(hostElement, { onHostOccupied, onHostVacated }) {\n    this.videoHostElementList = this.videoHostElementList.concat(hostElement);\n    this.videoHostOccupiedCallbacks.set(hostElement, onHostOccupied);\n    this.videoHostVacatedCallbacks.set(hostElement, onHostVacated);\n  }\n\n  renderVideoIntoHostElement(hostElement) {\n    if (this.videoHostElementList.indexOf(hostElement) === -1) {\n      return;\n    }\n    cancelAnimationFrame(this.videoHostUpdateRaf);\n    this.videoHostUpdateRaf = requestAnimationFrame(() =>\n      this.updateVideoHostElement(hostElement)\n    );\n  }\n\n  unregisterVideoHostElement(hostElement) {\n    this.videoHostElementList = this.videoHostElementList.filter(\n      elem => elem !== hostElement\n    );\n    this.videoHostOccupiedCallbacks.delete(hostElement);\n    this.videoHostVacatedCallbacks.delete(hostElement);\n    if (this.media.parentNode === hostElement) {\n      this.updateVideoHostElement();\n    }\n  }\n\n  updateVideoHostElement(hostElement) {\n    if (!hostElement) {\n      hostElement = this.videoHostElementList[0] || this.mediaContainer;\n    } else {\n      // move hostElement to front of list\n      this.videoHostElementList = [hostElement].concat(\n        this.videoHostElementList.filter(elem => elem !== hostElement)\n      );\n    }\n    const playing = !this.media.paused;\n    const oldHostElement = this.media.parentNode;\n    if (hostElement === oldHostElement) {\n      return;\n    }\n    hostElement.appendChild(this.media);\n    // according to the HTML spec playback should continue, but\n    // some browsers pause the element whenever it is moved around, so\n    // let's make sure playback resumes if that's the case.\n    if (playing && this.media.paused) {\n      this.media.play();\n    }\n    const onVacated = this.videoHostVacatedCallbacks.get(oldHostElement);\n    if (onVacated) {\n      onVacated(this.media);\n    }\n    const onOccupied = this.videoHostOccupiedCallbacks.get(hostElement);\n    if (onOccupied) {\n      onOccupied(this.media);\n    }\n  }\n\n  handleMediaPlay() {\n    this.setState(\n      state =>\n        state.paused === false && state.awaitingPlayAfterTrackLoad === false\n          ? null\n          : { paused: false, awaitingPlayAfterTrackLoad: false }\n    );\n    this.stealMediaSession();\n  }\n\n  handleMediaPause() {\n    this.setState(state => (state.paused === true ? null : { paused: true }));\n  }\n\n  handleMediaSrcrequest(e) {\n    const { playlist } = this.props;\n    const sources = getTrackSources(playlist, this.state.activeTrackIndex);\n    if (arrayFindIndex(sources, s => s.src === e.srcRequested) !== -1) {\n      // we're good! nothing to update.\n      return;\n    }\n    // looks like 'src' was set from outside our component.\n    // let's see if we can use it.\n    const newTrackIndex = findTrackIndexByUrl(playlist, e.srcRequested);\n    if (newTrackIndex === -1) {\n      logError(\n        `Source '${e.srcRequested}' does not exist in the loaded playlist. ` +\n          `Make sure you've updated the 'playlist' prop to ` +\n          `PlayerContextProvider before you select this track!`\n      );\n      return;\n    }\n    this.selectTrackIndex(newTrackIndex);\n  }\n\n  handleMediaEnded() {\n    if (this.state.seekInProgress) {\n      // nothing to do if we're in the middle of a seek\n      // (this can happen if we're in seekMode: immediate)\n      return;\n    }\n    clearTimeout(this.gapLengthTimeout);\n    const { playlist, loadFirstTrackOnPlaylistComplete } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    const { cycle, activeTrackIndex } = this.state;\n    if (!cycle && activeTrackIndex + 1 >= playlist.length) {\n      if (loadFirstTrackOnPlaylistComplete) {\n        this.goToTrack({\n          index: 0,\n          track: playlist[0],\n          shouldPlay: false,\n          shouldForceLoad: true\n        });\n      }\n      return;\n    }\n    this.gapLengthTimeout = setTimeout(\n      this.forwardSkip,\n      this.props.gapLengthInSeconds * 1000\n    );\n  }\n\n  handleMediaStalled() {\n    this.setState(state => (state.stalled === true ? null : { stalled: true }));\n  }\n\n  handleMediaEmptied() {\n    this.setState(state => (state.paused === true ? null : { paused: true }));\n  }\n\n  handleMediaCanplay() {\n    this.setState(\n      state => (state.trackLoading === false ? null : { trackLoading: false })\n    );\n  }\n\n  handleMediaCanplaythrough() {\n    this.setState(\n      state => (state.stalled === false ? null : { stalled: false })\n    );\n  }\n\n  handleMediaTimeupdate() {\n    const { currentTime, played } = this.media;\n    const { onTimeUpdate, playlist } = this.props;\n    const { activeTrackIndex, trackLoading } = this.state;\n    if (trackLoading) {\n      // we'll get another time update when the track loads\n      // but for now this helps us avoid unnecessarily\n      // jumping back to currentTime: 0 in the UI while\n      // the track is loading.\n      return;\n    }\n    this.setState(state => ({\n      currentTime,\n      playedRanges: getTimeRangesArray(played),\n      maxKnownTime: Math.max(state.maxKnownTime, currentTime)\n    }));\n    if (onTimeUpdate) {\n      onTimeUpdate({\n        currentTime,\n        track: playlist[activeTrackIndex],\n        trackIndex: activeTrackIndex\n      });\n    }\n  }\n\n  handleMediaLoadeddata() {\n    if (this.media.currentTime !== this.state.currentTime) {\n      this.media.currentTime = this.state.currentTime;\n    }\n  }\n\n  handleMediaVolumechange() {\n    const { volume, muted } = this.media;\n    this.setState({ volume, muted });\n  }\n\n  handleMediaDurationchange() {\n    const { duration } = this.media;\n    const activeTrack = this.props.playlist[this.state.activeTrackIndex];\n    if (duration === Infinity) {\n      // This *could* be because we're consuming an unbounded stream.\n      // It could also be because of a weird iOS bug that we want to\n      // try to prevent. See https://github.com/benwiley4000/cassette/issues/355\n\n      // If we still end up with Infinity duration multiple times for\n      // the same track, we'll assume it's correct.\n      if (\n        activeTrack.isUnboundedStream ||\n        activeTrack === this.activeTrackAtLastDurationChange\n      ) {\n        this.setState({\n          duration,\n          currentTime: 0\n        });\n        this.media.currentTime = 0;\n      } else {\n        const { paused } = this.state;\n        this.media.load();\n        if (!paused) {\n          // media.currentSrc is updated asynchronously so we should\n          // play async to avoid weird intermediate state issues\n          setTimeout(() => {\n            this.togglePause(false);\n          });\n        }\n      }\n    } else {\n      this.setState({ duration });\n    }\n    this.activeTrackAtLastDurationChange = activeTrack;\n  }\n\n  handleMediaProgress() {\n    this.setState({\n      bufferedRanges: getTimeRangesArray(this.media.buffered),\n      seekableRanges: getTimeRangesArray(this.media.seekable)\n    });\n  }\n\n  handleMediaLoopchange() {\n    const { loop } = this.media;\n    this.setState(state => (state.loop === loop ? null : { loop }));\n  }\n\n  handleMediaRatechange() {\n    const { playbackRate } = this.media;\n    this.setState(\n      state => (state.playbackRate === playbackRate ? null : { playbackRate })\n    );\n  }\n\n  togglePause(value) {\n    clearTimeout(this.delayTimeout);\n    const pause = typeof value === 'boolean' ? value : !this.state.paused;\n    if (pause) {\n      this.media.pause();\n      return;\n    }\n    if (!this.media.currentSrc) {\n      return;\n    }\n    try {\n      const playPromise = this.media.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise\n          .catch(err => {\n            // AbortError is pretty much always called because we're skipping\n            // tracks quickly or hitting pause before a track has a chance to\n            // play. It's pretty safe to just ignore these error messages.\n            if (err.name !== 'AbortError') {\n              return Promise.reject(err);\n            }\n          })\n          .catch(playErrorHandler);\n      }\n    } catch (err) {\n      playErrorHandler(err);\n    }\n  }\n\n  // assumes playlist is valid - don't call without checking\n  goToTrack(args) {\n    clearTimeout(this.delayTimeout);\n    this.setState(prevState => getGoToTrackState({ prevState, ...args }));\n  }\n\n  selectTrackIndex(index) {\n    const { playlist } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    if (index < 0 || index > playlist.length) {\n      logWarning(`Playlist index ${index} is out of bounds!`);\n      return;\n    }\n    if (this.state.shuffle) {\n      this.shuffler.pickNextItem(index, this.state.activeTrackIndex);\n    }\n    this.goToTrack({ index, track: playlist[index] });\n  }\n\n  backSkip() {\n    const { playlist, stayOnBackSkipThreshold } = this.props;\n    const { media } = this;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      media.currentTime >= stayOnBackSkipThreshold ||\n      (!cycle && activeTrackIndex < 1)\n    ) {\n      media.currentTime = 0;\n      return;\n    }\n    let index;\n    if (shuffle) {\n      const previousItem = this.shuffler.findPreviousItem(activeTrackIndex);\n      if (previousItem === undefined) {\n        // if we aren't allowing backShuffle then we'll hit a stopping point.\n        media.currentTime = 0;\n        return;\n      }\n      index = findTrackIndexByUrl(playlist, previousItem);\n    } else {\n      index = activeTrackIndex - 1;\n      if (index < 0) {\n        index = playlist.length - 1;\n      }\n    }\n    this.goToTrack({ index, track: playlist[index], shouldForceLoad: true });\n  }\n\n  forwardSkip() {\n    const { playlist } = this.props;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      (!cycle && activeTrackIndex + 1 >= playlist.length)\n    ) {\n      return;\n    }\n    let index;\n    if (shuffle) {\n      index = findTrackIndexByUrl(\n        playlist,\n        this.shuffler.findNextItem(activeTrackIndex)\n      );\n    } else {\n      index = activeTrackIndex + 1;\n      if (index >= playlist.length) {\n        index = 0;\n      }\n    }\n    this.goToTrack({ index, track: playlist[index], shouldForceLoad: true });\n  }\n\n  seekPreview(targetTime) {\n    if (!isPlaylistValid(this.props.playlist)) {\n      return;\n    }\n    const baseStateUpdate = {\n      seekPreviewTime: targetTime,\n      seekInProgress: true\n    };\n    switch (this.props.seekMode) {\n      case 'paused':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true,\n          currentTime: targetTime\n        }));\n        if (!this.state.trackLoading) {\n          this.media.currentTime = targetTime;\n        }\n        if (!this.state.paused) {\n          this.togglePause(true);\n        }\n        break;\n      case 'immediate':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true,\n          currentTime: targetTime\n        }));\n        if (!this.state.trackLoading) {\n          this.media.currentTime = targetTime;\n        }\n        if (this.state.awaitingResumeOnSeekComplete && !this.media.ended) {\n          // if we earlier encountered an 'ended' state,\n          // un-pausing becomes necessary to resume playback\n          this.togglePause(false);\n        }\n        break;\n      case 'onrelease':\n        this.setState(baseStateUpdate);\n        break;\n    }\n  }\n\n  seekComplete(targetTime) {\n    const {\n      seekPreviewTime,\n      awaitingResumeOnSeekComplete,\n      trackLoading\n    } = this.state;\n    const baseStateUpdate = {\n      seekInProgress: false,\n      awaitingResumeOnSeekComplete: false\n    };\n    const currentTime =\n      typeof targetTime === 'number' ? targetTime : seekPreviewTime;\n\n    if (isNaN(currentTime)) {\n      this.setState(baseStateUpdate);\n      return;\n    }\n    this.setState({\n      ...baseStateUpdate,\n      /* we'll update currentTime on the media listener hook anyway,\n       * but that might not happen for a bit... so the optimistic update\n       * helps us avoid the progress bar jumping around and confusing the user.\n       * https://github.com/benwiley4000/cassette/issues/209\n       */\n      currentTime\n    });\n    if (!trackLoading) {\n      this.media.currentTime = currentTime;\n    }\n    if (awaitingResumeOnSeekComplete) {\n      if (this.media.ended) {\n        this.forwardSkip();\n      } else {\n        this.togglePause(false);\n      }\n    }\n  }\n\n  setVolume(volume, inProgress = true) {\n    if (inProgress && !this.state.setVolumeInProgress) {\n      this.setState({\n        setVolumeInProgress: true\n      });\n    }\n    const volumeInBounds = convertToNumberWithinIntervalBounds(volume, 0, 1);\n    this.media.muted = volumeInBounds === 0 ? true : false;\n    this.media.volume = volumeInBounds;\n  }\n\n  setVolumeComplete(volume) {\n    if (typeof volume === 'number') {\n      this.setVolume(volume, false);\n    }\n    this.setState({\n      setVolumeInProgress: false\n    });\n    if (!this.media.muted) {\n      this.lastStableVolume = this.media.volume;\n    }\n  }\n\n  toggleMuted(value) {\n    const muted = typeof value === 'boolean' ? value : !this.state.muted;\n    this.media.muted = muted;\n    if (!muted) {\n      this.media.volume = this.lastStableVolume;\n    }\n  }\n\n  toggleShuffle(value) {\n    const shuffle = typeof value === 'boolean' ? value : !this.state.shuffle;\n    this.setState({ shuffle });\n  }\n\n  setRepeatStrategy(repeatStrategy) {\n    if (repeatStrategyOptions.indexOf(repeatStrategy) === -1) {\n      logWarning(\n        'repeatStrategy \"' +\n          repeatStrategy +\n          '\" is not one of: ' +\n          repeatStrategyOptions.split(', ') +\n          '.'\n      );\n      return;\n    }\n    switch (repeatStrategy) {\n      case 'track':\n        // state update is automatic\n        this.media.loop = true;\n        break;\n      case 'playlist':\n        this.setState({\n          loop: false,\n          cycle: true\n        });\n        this.media.loop = false;\n        break;\n      case 'none':\n        this.setState({\n          loop: false,\n          cycle: false\n        });\n        this.media.loop = false;\n        break;\n    }\n  }\n\n  setPlaybackRate(rate) {\n    this.media.playbackRate = rate;\n  }\n\n  getControlProps() {\n    const { props, state } = this;\n    const playerContext = {\n      playlist: props.playlist,\n      activeTrackIndex: state.activeTrackIndex,\n      trackLoading: state.trackLoading,\n      paused: state.paused,\n      currentTime: state.currentTime,\n      seekPreviewTime: state.seekPreviewTime,\n      seekInProgress: state.seekInProgress,\n      awaitingPlayResume:\n        state.awaitingResumeOnSeekComplete || state.awaitingPlayAfterTrackLoad,\n      duration:\n        state.duration === Infinity ? state.maxKnownTime : state.duration,\n      bufferedRanges: state.bufferedRanges,\n      playedRanges: state.playedRanges,\n      seekableRanges: state.seekableRanges,\n      volume: state.volume,\n      muted: state.muted,\n      shuffle: state.shuffle,\n      stalled: state.stalled,\n      playbackRate: state.playbackRate,\n      mediaCannotPlay: state.mediaCannotPlay,\n      setVolumeInProgress: state.setVolumeInProgress,\n      repeatStrategy: getRepeatStrategy(state.loop, state.cycle),\n      registerVideoHostElement: this.registerVideoHostElement,\n      renderVideoIntoHostElement: this.renderVideoIntoHostElement,\n      unregisterVideoHostElement: this.unregisterVideoHostElement,\n      onTogglePause: this.togglePause,\n      onSelectTrackIndex: this.selectTrackIndex,\n      onBackSkip: this.backSkip,\n      onForwardSkip: this.forwardSkip,\n      onSeekPreview: this.seekPreview,\n      onSeekComplete: this.seekComplete,\n      onSetVolume: this.setVolume,\n      onSetVolumeComplete: this.setVolumeComplete,\n      onToggleMuted: this.toggleMuted,\n      onToggleShuffle: this.toggleShuffle,\n      onSetRepeatStrategy: this.setRepeatStrategy,\n      onSetPlaybackRate: this.setPlaybackRate,\n      reloadActiveTrack: this.reloadActiveTrack\n    };\n    if (this.playerContext) {\n      // only update this.playerContext if something has changed\n      for (const key of Object.keys(this.playerContext)) {\n        if (playerContext[key] !== this.playerContext[key]) {\n          this.playerContext = playerContext;\n          break;\n        }\n      }\n    } else {\n      // first time - nothing to compare\n      this.playerContext = playerContext;\n    }\n    return this.playerContext;\n  }\n\n  render() {\n    const playerContext = this.getControlProps();\n    return (\n      <Fragment>\n        <div ref={elem => (this.mediaContainer = elem)} hidden />\n        <PlayerContext.Provider value={playerContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(playerContext)\n            : this.props.children}\n        </PlayerContext.Provider>\n      </Fragment>\n    );\n  }\n}\n\nPlayerContextProvider.propTypes = {\n  /**\n   * An array of [`track`](#track) objects to play in order (except when\n   * shuffle mode is turned on)\n   **/\n  playlist: PropTypes.arrayOf(PlayerPropTypes.track.isRequired).isRequired,\n  /** Set to `true` to play media on player load. Think before doing this. It is\n   * often a bad idea, although it can make sense if your app is expressly made\n   * for media playback and you're resuming playback from the last session.\n   * Note that some platforms will disallow this from happening under many\n   * scenarios, and in these cases, `autoplay` will simply fail gracefully.\n   */\n  autoplay: PropTypes.bool.isRequired,\n  /**\n   * If your app uses a custom implementation of the `HTMLMediaElement`, you\n   * can supply your own factory function to return it. This is an advanced\n   * edge case.\n   */\n  createMediaElement: PropTypes.func.isRequired,\n  /** If you're using `autoplay` but want to wait a few seconds before the\n   * media playback kicks in, you can specify that timeout in second here.\n   */\n  autoplayDelayInSeconds: PropTypes.number.isRequired,\n  /**\n   * Similar to `autoplayDelayInSeconds` but for the pause between tracks\n   * (if you want to evoke the feeling of listening to one of those old CDs with\n   * a negative countdown before it starts, which you never asked for).\n   */\n  gapLengthInSeconds: PropTypes.number.isRequired,\n  /** A [`crossOriginAttribute`](#crossoriginattribute) value */\n  crossOrigin: PlayerPropTypes.crossOriginAttribute,\n  /** The starting volume (0-1) */\n  defaultVolume: PropTypes.number.isRequired,\n  /** The starting `muted` value (`true` or `false`) */\n  defaultMuted: PropTypes.bool,\n  /** The starting [`repeatStrategy`](#repeatstrategy) */\n  defaultRepeatStrategy: PlayerPropTypes.repeatStrategy.isRequired,\n  /** Will shuffle mode be active by default? */\n  defaultShuffle: PropTypes.bool,\n  /** The starting playback rate (1 is normal, 0.5 is half, 2 is double) */\n  defaultPlaybackRate: PropTypes.number.isRequired,\n  /**\n   * The starting track index (an advanced use case.. normally you should put\n   * the track you want to hear first at the start of the playlist, unless\n   * you are loading an `initialStateSnapshot` which will override this value\n   * anyway\n   */\n  startingTrackIndex: PropTypes.number.isRequired,\n  /**\n   * Set this `false` if the player should rest of the final track when\n   * the playlist has completed. Ignored unless the\n   * current [`repeatStrategy`](#repeatstrategy) is `none`\n   */\n  loadFirstTrackOnPlaylistComplete: PropTypes.bool,\n  /** Use this to set the player's [`seekMode`](#seekmode) */\n  seekMode: PlayerPropTypes.seekMode.isRequired,\n  /**\n   * The default media element behavior is to reset the `playbackRate` to 1\n   * whenever a new source is loaded. Set this prop to `true` to maintain the\n   * same irregular playback rate across multiple tracks.\n   */\n  maintainPlaybackRate: PropTypes.bool.isRequired,\n  /**\n   * By default, activating a back skip in shuffle mode will select the previous\n   * track in the shuffled list, but if the current track was the first selected\n   * track, back skip will be disabled. Setting this prop to `true` will\n   * select new arbitrary tracks in the \"past\" if back skip is used beyond\n   * the buffered history.\n   */\n  allowBackShuffle: PropTypes.bool,\n  /**\n   * The number of seconds before pressing back skip becomes \"back to\n   * beginning of current track\" rather than \"go to the previous track\"\n   */\n  stayOnBackSkipThreshold: PropTypes.number.isRequired,\n  /**\n   * An array of [`mediaSessionAction`](#mediasessionaction) types to display\n   * in the end users's system UI, when applicable.\n   * It is *not* the same as the `controls` array.\n   */\n  supportedMediaSessionActions: PropTypes.arrayOf(\n    PlayerPropTypes.mediaSessionAction.isRequired\n  ).isRequired,\n  /** The number of seconds to seek back or forward when the Media Session API\n   * backseek/forwardseek buttons are activated in the end user's system UI\n   */\n  mediaSessionSeekLengthInSeconds: PropTypes.number.isRequired,\n  /**\n   * A function called on component mount and component unmount with a reference\n   * to the underlying media element. Generally not recommended for use, but\n   * can be used as an escape hatch for features that aren't well-supported by\n   * Cassette (if you find yourself needing this, you may want to\n   * [open a new issue](https://github.com/benwiley4000/cassette/issues/new)\n   * to talk about adding first-class support for your use case).\n   */\n  mediaElementRef: PropTypes.func,\n  /**\n   * If you're using `onStateSnapshot` to save snapshots of the media player\n   * state as a serializable object, you should pass that restored object here\n   * to preserve the user's state from the previous session\n   */\n  initialStateSnapshot: PropTypes.object,\n  /**\n   * Called whenever a new state snapshot is generated. The internals of this\n   * snapshot are not documented and may change in a non-major release, so it's\n   * not safe to rely on them directly. Instead, the state snapshot should\n   * be serialized to JSON with `JSON.stringify` and restored later with\n   * `JSON.parse` to be passed as the `initialStateSnapshot` prop\n   */\n  onStateSnapshot: PropTypes.func,\n  /**\n   * A function called whenever the active track is set or updated. Passed an\n   * object with the properties `track`, `trackIndex`, `previousTrack` and\n   * `previousTrackIndex` (these may be `null` or `undefined`)\n   */\n  onActiveTrackUpdate: PropTypes.func,\n  /**\n   * A function called when the media element's `currentTime` attribute has\n   * changed. Passed an object with the properties `currentTime`, `track` and\n   * `trackIndex`\n   */\n  onTimeUpdate: PropTypes.func,\n  /**\n   * A function called when playback of the current track has failed for some\n   * reason. Passed an object with the properties `event`,\n   * `track` and `trackIndex`\n   */\n  onTrackPlaybackFailure: PropTypes.func,\n  /**\n   * A function which receives a [`track`](#track) object (if one is active)\n   * and returns a url pointing to a poster image representing the current\n   * track which should be used in a [`VideoDisplay`](#videodisplay) when the\n   * media content hasn't yet loaded\n   */\n  getPosterImageForTrack: PropTypes.func.isRequired,\n  /**\n   * A function which receives a [`track`](#track) object (if one is active)\n   * and returns the value for the media element's `title` attribute, which\n   * may be used in iOS to display information about the current track in the\n   * system UI\n   */\n  getMediaTitleAttributeForTrack: PropTypes.func.isRequired,\n  /**\n   * Either a renderable React node or a render prop function like the\n   * one passed into [`PlayerContextConsumer`](#playercontextconsumer)\n   */\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nPlayerContextProvider.defaultProps = {\n  autoplay: false,\n  autoplayDelayInSeconds: 0,\n  createMediaElement: () => document.createElement('video'),\n  gapLengthInSeconds: 0,\n  defaultVolume: 1,\n  defaultMuted: false,\n  defaultRepeatStrategy: 'playlist',\n  defaultShuffle: false,\n  defaultPlaybackRate: 1,\n  startingTrackIndex: 0,\n  loadFirstTrackOnPlaylistComplete: true,\n  seekMode: 'immediate',\n  maintainPlaybackRate: false,\n  allowBackShuffle: false,\n  stayOnBackSkipThreshold: 5,\n  supportedMediaSessionActions: ['play', 'pause', 'previoustrack', 'nexttrack'],\n  mediaSessionSeekLengthInSeconds: 10,\n  getPosterImageForTrack(track) {\n    return track && track.artwork ? track.artwork[0].src : '';\n  },\n  getMediaTitleAttributeForTrack: getDisplayText\n};\n\nexport class PlayerContextGroupMember extends Component {\n  componentDidMount() {\n    this.props.groupContext.registerMediaElement(this.mediaElement);\n  }\n\n  componentWillUnmount() {\n    // Media element might not exist\n    // (see componentWillUnmount of PlayerContextProvider)\n    if (this.mediaElement) {\n      this.props.groupContext.unregisterMediaElement(this.mediaElement);\n    }\n  }\n\n  render() {\n    const { groupContext, props } = this.props;\n    const { mediaElementRef, ...rest } = props;\n    return (\n      <PlayerContextProvider\n        {...groupContext.groupProps}\n        {...rest}\n        mediaElementRef={ref => {\n          if (mediaElementRef) {\n            mediaElementRef(ref);\n          }\n          this.mediaElement = ref;\n        }}\n      />\n    );\n  }\n}\n\nPlayerContextGroupMember.propTypes = {\n  groupContext: PropTypes.shape({\n    groupProps: PropTypes.object.isRequired,\n    registerMediaElement: PropTypes.func.isRequired,\n    unregisterMediaElement: PropTypes.func.isRequired\n  }).isRequired\n};\n\nfunction PlayerContextGroupConsumer(props) {\n  return (\n    <GroupContext.Consumer>\n      {groupContext => {\n        if (!groupContext) {\n          return createElement(PlayerContextProvider, props);\n        }\n        return createElement(PlayerContextGroupMember, {\n          groupContext,\n          props\n        });\n      }}\n    </GroupContext.Consumer>\n  );\n}\n\nexport default PlayerContextGroupConsumer;\n","// TODO: support Preact, Inferno, etc.\nfunction getReactParentNameStack(componentInstance) {\n  const fiber = componentInstance._reactInternalFiber;\n  const parentStack = [];\n  let owner = fiber;\n  if (!owner) {\n    return parentStack;\n  }\n  while ((owner = owner._debugOwner)) {\n    if (owner.type.name) {\n      parentStack.push(owner.type.name);\n    }\n  }\n  return parentStack;\n}\n\nexport default getReactParentNameStack;\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport PlayerContext from './PlayerContext';\n\nimport { logWarning } from './utils/console';\nimport getReactParentNameStack from './utils/getReactParentNameStack';\n\nclass PlayerContextConsumer extends PureComponent {\n  render() {\n    const { children, filterList } = this.props;\n    if (!filterList) {\n      if (!this.warnedAboutFilterList) {\n        let warning = `\n          Please pass the filterList prop to PlayerContextConsumer in order\n          to avoid unnecessarily frequent re-renders, e.g.\n\n          const filterList = ['paused', 'onTogglePause'];\n          // ...\n          <PlayerContextConsumer filterList={filterList}>\n            {({ paused, onTogglePause }) => {\n              return <div>{/* ... */}</div>;\n            }}\n          </PlayerContextConsumer>\n        `;\n        for (const parentName of getReactParentNameStack(this)) {\n          warning += `\n            Rendered by ${parentName}`;\n        }\n        logWarning(warning);\n        this.warnedAboutFilterList = true;\n      }\n      return <PlayerContext.Consumer>{children}</PlayerContext.Consumer>;\n    }\n\n    const flags = PlayerContext.__cassetteGetObservedBits(filterList);\n    return (\n      <PlayerContext.Consumer unstable_observedBits={flags}>\n        {playerContext => {\n          const usedContext = {};\n          for (const name of filterList) {\n            if (playerContext.hasOwnProperty(name)) {\n              usedContext[name] = playerContext[name];\n            }\n          }\n          return children(usedContext);\n        }}\n      </PlayerContext.Consumer>\n    );\n  }\n}\n\nPlayerContextConsumer.propTypes = {\n  /**\n   * A [render prop](https://reactjs.org/docs/render-props.html) function\n   * which receives as its argument an object with the latest values of the\n   * keys specified in the `filterList` prop (if you forget `filterList`, you\n   * will get all the `playerContext` values and a warning in the console)\n   */\n  children: PropTypes.func.isRequired,\n  /**\n   * A full list of `playerContext` values which will need to be consumed.\n   * Similar to the prop name array passed to\n   * [`playerContextFilter`](#playercontextfilter), but only made up of values\n   * found in [`playerContext`](#playercontext).\n   *\n   */\n  filterList: PropTypes.arrayOf(PropTypes.string.isRequired)\n};\n\nexport default PlayerContextConsumer;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport GroupContext from './GroupContext';\n\n/**\n * A wrapper which can be used to share configuration among multiple descendant [`PlayerContextProvider`](#playercontextprovider) instances as well as prevent multiple media elements from playing audio simultaneously\n */\nexport class PlayerContextGroup extends Component {\n  constructor(props) {\n    super(props);\n    this.registerMediaElement = this.registerMediaElement.bind(this);\n    this.unregisterMediaElement = this.unregisterMediaElement.bind(this);\n    this.enforceOneMediaSourceOnly = this.enforceOneMediaSourceOnly.bind(this);\n    this.mediaElements = [];\n  }\n\n  registerMediaElement(elem) {\n    this.mediaElements = this.mediaElements.concat(elem);\n    elem.addEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.addEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n  }\n\n  unregisterMediaElement(elem) {\n    this.mediaElements = this.mediaElements.filter(element => elem !== element);\n    elem.removeEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.removeEventListener(\n      'volumechange',\n      this.enforceOneMediaSourceOnly,\n      true\n    );\n  }\n\n  enforceOneMediaSourceOnly(e) {\n    const mediaElement = e.target;\n    const { paused, muted } = mediaElement;\n    if (paused || muted) {\n      return;\n    }\n    for (const element of this.mediaElements) {\n      if (element !== mediaElement && !element.muted) {\n        element.pause();\n      }\n    }\n  }\n\n  render() {\n    return (\n      <GroupContext.Consumer>\n        {groupContext => {\n          const value = groupContext\n            ? {\n                ...groupContext,\n                groupProps: { ...groupContext.groupProps, ...this.props }\n              }\n            : {\n                groupProps: this.props,\n                registerMediaElement: this.registerMediaElement,\n                unregisterMediaElement: this.unregisterMediaElement\n              };\n          return (\n            <GroupContext.Provider value={value}>\n              {this.props.children}\n            </GroupContext.Provider>\n          );\n        }}\n      </GroupContext.Consumer>\n    );\n  }\n}\n\nPlayerContextGroup.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\nexport default PlayerContextGroup;\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\nimport { logWarning } from './utils/console';\n\nexport default createSingleGlobalContext({\n  displayName: 'FullscreenContext',\n  defaultValue: {\n    fullscreen: false,\n    requestFullscreen() {\n      logWarning(\n        'Fullscreen request ignored since there is no ' +\n          'FullscreenContextProvider ancestor.'\n      );\n    },\n    requestExitFullscreen() {\n      logWarning(\n        'Exit fullscreen request ignored since there is no ' +\n          'FullscreenContextProvider ancestor.'\n      );\n    }\n  },\n  keysWillUpdate: ['fullscreen']\n});\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nimport FullscreenContext from './FullscreenContext';\n\nconst fullscreenStyle = {\n  width: '100%',\n  height: '100%'\n};\n\n/**\n * Wraps an area which should be fullscreen-able\n */\nexport class FullscreenContextProvider extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fullscreen: false\n    };\n    this.requestFullscreen = this.requestFullscreen.bind(this);\n    this.requestExitFullscreen = this.requestExitFullscreen.bind(this);\n    this.handleFullscreenChange = this.handleFullscreenChange.bind(this);\n    this.fullscreenElement = null;\n  }\n\n  componentDidMount() {\n    document.addEventListener('fullscreenchange', this.handleFullscreenChange);\n    document.addEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\n      'fullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  requestFullscreen() {\n    if (!this.props.fullscreenEnabled) {\n      return;\n    }\n    if (this.fullscreenElement.requestFullscreen) {\n      this.fullscreenElement.requestFullscreen();\n    } else if (this.fullscreenElement.webkitRequestFullscreen) {\n      this.fullscreenElement.webkitRequestFullscreen();\n    } else if (this.fullscreenElement.mozRequestFullscreen) {\n      this.fullscreenElement.mozRequestFullScreen();\n    } else if (this.fullscreenElement.msRequestFullscreen) {\n      this.fullscreenElement.msRequestFullscreen();\n    }\n  }\n\n  requestExitFullscreen() {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.msExitFullscreen) {\n      document.mozExitFullscreen();\n    }\n  }\n\n  handleFullscreenChange() {\n    const documentFullscreenElement =\n      document.fullscreenElement ||\n      document.webkitFullscreenElement ||\n      document.mozFullScreenElement ||\n      document.msFullscreenElement;\n    this.setState({\n      fullscreen: documentFullscreenElement === this.fullscreenElement\n    });\n  }\n\n  getFullscreenContext() {\n    const fullscreenContext = {\n      fullscreen: this.state.fullscreen,\n      requestFullscreen: this.requestFullscreen,\n      requestExitFullscreen: this.requestExitFullscreen\n    };\n    if (\n      this.fullscreenContext &&\n      fullscreenContext.fullscreen === this.fullscreenContext.fullscreen\n    ) {\n      // no change\n      return this.fullscreenContext;\n    }\n    return (this.fullscreenContext = fullscreenContext);\n  }\n\n  render() {\n    const fullscreenContext = this.getFullscreenContext();\n    return (\n      <div\n        ref={elem => (this.fullscreenElement = elem)}\n        style={this.state.fullscreen ? fullscreenStyle : undefined}\n      >\n        <FullscreenContext.Provider value={fullscreenContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(fullscreenContext)\n            : this.props.children}\n        </FullscreenContext.Provider>\n      </div>\n    );\n  }\n}\n\nFullscreenContextProvider.propTypes = {\n  /** If set `false`, disables fullscreen for the wrapped area */\n  fullscreenEnabled: PropTypes.bool.isRequired,\n  /**\n   * Either a renderable React node or a render prop function like the\n   * one passed into [`FullscreenContextConsumer`](#fullscreencontextconsumer)\n   */\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nFullscreenContextProvider.defaultProps = {\n  fullscreenEnabled: true\n};\n\nexport default FullscreenContextProvider;\n","import React, { createElement } from 'react';\n\nimport PlayerContext from './PlayerContext';\nimport FullscreenContext from './FullscreenContext';\nimport { logWarning } from './utils/console';\n\nfunction playerContextFilter(component, contextPropNames) {\n  const warned = {};\n  const childName = component.displayName || component.name;\n  const flags = PlayerContext.__cassetteGetObservedBits(contextPropNames);\n  function PlayerContextFilter(props) {\n    return (\n      <FullscreenContext.Consumer>\n        {fullscreenContext => (\n          <PlayerContext.Consumer unstable_observedBits={flags}>\n            {playerContext => {\n              const childProps = { ...props };\n              for (const propName of contextPropNames) {\n                if (playerContext.hasOwnProperty(propName)) {\n                  childProps[propName] = playerContext[propName];\n                } else if (fullscreenContext.hasOwnProperty(propName)) {\n                  childProps[propName] = fullscreenContext[propName];\n                } else if (!warned[propName]) {\n                  logWarning(\n                    \"Prop '\" +\n                      propName +\n                      \"' for component \" +\n                      childName +\n                      ' not found in playerContext or fullscreenContext.'\n                  );\n                  warned[propName] = true;\n                }\n              }\n              return createElement(component, childProps);\n            }}\n          </PlayerContext.Consumer>\n        )}\n      </FullscreenContext.Consumer>\n    );\n  }\n  if (childName) {\n    PlayerContextFilter.displayName = `PlayerContextFilter(${childName})`;\n  }\n  return PlayerContextFilter;\n}\n\nexport default playerContextFilter;\n","import PlayerContextProvider from './PlayerContextProvider';\nimport PlayerContext from './PlayerContext';\nimport PlayerContextConsumer from './PlayerContextConsumer';\nimport PlayerContextGroup from './PlayerContextGroup';\nimport FullscreenContextProvider from './FullscreenContextProvider';\nimport FullscreenContext from './FullscreenContext';\nimport playerContextFilter from './playerContextFilter';\nimport * as PlayerPropTypes from './PlayerPropTypes';\n\nexport { PlayerContextProvider };\nexport { PlayerContextConsumer };\nexport { PlayerContextGroup };\nexport { FullscreenContextProvider };\nexport const FullscreenContextConsumer = FullscreenContext.Consumer;\nexport { playerContextFilter };\nexport { PlayerPropTypes };\n\n// undocumented exports\nexport * from './utils/console';\nexport {\n  default as convertToNumberWithinIntervalBounds\n} from './utils/convertToNumberWithinIntervalBounds';\nexport { default as isPlaylistValid } from './utils/isPlaylistValid';\nexport { default as getDisplayText } from './utils/getDisplayText';\nexport { repeatStrategyOptions } from './constants';\nexport const donotuse_PlayerContext = PlayerContext;\nexport const donotuse_FullscreenContext = FullscreenContext;\n"],"sourceRoot":""}